/**
 * MALWARE SAMPLE SEQUELIZE MODEL
 * Represents malware samples and analysis results with comprehensive type safety
 */
import {
  Table,
  Column,
  Model,
  PrimaryKey,
  AutoIncrement,
  AllowNull,
  Default,
  CreatedAt,
  UpdatedAt,
  BelongsTo,
  HasMany,
  ForeignKey,
  Unique,
  DataType,
  Index,
  Length
} from 'sequelize-typescript';
import { Optional } from 'sequelize';
import { Op } from 'sequelize';
import { User } from './User.model';
import { ThreatActor } from './ThreatActor.model';
import { IOC } from './IOC.model';

// MalwareSample Attributes Interface
export interface MalwareSampleAttributes {
  /** Unique identifier for the malware sample */
  id: number;
  /** Name of the malware sample */
  name: string;
  /** MD5 hash of the file */
  md5_hash: string;
  /** SHA1 hash of the file */
  sha1_hash: string;
  /** SHA256 hash of the file */
  sha256_hash: string;
  /** SHA512 hash of the file */
  sha512_hash?: string;
  /** SSDEEP fuzzy hash */
  ssdeep_hash?: string;
  /** File size in bytes */
  file_size?: number;
  /** MIME type or file type */
  file_type?: string;
  /** Original filename when discovered */
  original_filename?: string;
  /** Malware family classification */
  malware_family: string;
  /** Types of malware (Trojan, Ransomware, etc.) */
  malware_types: string[];
  /** Associated threat actor ID */
  threat_actor_id?: number;
  /** Analyst who processed this sample */
  analyst_id?: number;
  /** Current analysis status */
  analysis_status: 'pending' | 'analyzing' | 'complete' | 'failed' | 'queued';
  /** When the sample was first observed */
  first_seen?: Date;
  /** When the sample was last observed */
  last_seen?: Date;
  /** Static analysis results */
  static_analysis: Record<string, any>;
  /** Dynamic analysis results */
  dynamic_analysis: Record<string, any>;
  /** Sandbox execution results */
  sandbox_results: Record<string, any>;
  /** YARA rules that matched */
  yara_rules_matched: string[];
  /** Network-based indicators */
  network_indicators: string[];
  /** File-based indicators */
  file_indicators: string[];
  /** Registry-based indicators */
  registry_indicators: string[];
  /** Behavioral indicators */
  behavioral_indicators: string[];
  /** Malware capabilities */
  capabilities: string[];
  /** Command and control domains */
  c2_domains: string[];
  /** Command and control IP addresses */
  c2_ips: string[];
  /** Files dropped by the malware */
  dropped_files: string[];
  /** Mutex names created */
  mutex_names: string[];
  /** Process names spawned */
  process_names: string[];
  /** Service names created */
  service_names: string[];
  /** Portable Executable file information */
  pe_info: Record<string, any>;
  /** String analysis results */
  strings_analysis: Record<string, any>;
  /** Import/Export analysis */
  imports_exports: Record<string, any>;
  /** Packer detection information */
  packer_info: Record<string, any>;
  /** Encryption analysis */
  encryption_info: Record<string, any>;
  /** Antivirus detection results */
  av_detections: Record<string, any>;
  /** Number of AV engines that detected */
  detection_ratio: number;
  /** Total number of AV engines scanned */
  total_scanned: number;
  /** Severity level assessment */
  severity: 'low' | 'medium' | 'high' | 'critical';
  /** Classification tags */
  tags: string[];
  /** Intelligence sources */
  sources: string[];
  /** Additional metadata */
  metadata: Record<string, any>;
  /** Record creation timestamp */
  created_at: Date;
  /** Record last update timestamp */
  updated_at: Date;
}

// MalwareSample Creation Attributes Interface
export interface MalwareSampleCreationAttributes extends Optional<MalwareSampleAttributes,
  'id' | 'sha512_hash' | 'ssdeep_hash' | 'file_size' | 'file_type' | 'original_filename' |
  'malware_family' | 'malware_types' | 'threat_actor_id' | 'analyst_id' | 'analysis_status' |
  'first_seen' | 'last_seen' | 'static_analysis' | 'dynamic_analysis' | 'sandbox_results' |
  'yara_rules_matched' | 'network_indicators' | 'file_indicators' | 'registry_indicators' |
  'behavioral_indicators' | 'capabilities' | 'c2_domains' | 'c2_ips' | 'dropped_files' |
  'mutex_names' | 'process_names' | 'service_names' | 'pe_info' | 'strings_analysis' |
  'imports_exports' | 'packer_info' | 'encryption_info' | 'av_detections' | 'detection_ratio' |
  'total_scanned' | 'severity' | 'tags' | 'sources' | 'metadata' | 'created_at' | 'updated_at'
> {}

@Table({
  tableName: 'malware_samples',
  timestamps: true,
  underscored: true,
  paranoid: false,
  indexes: [
    { fields: ['name'] },
    { fields: ['md5_hash'], unique: true },
    { fields: ['sha1_hash'], unique: true },
    { fields: ['sha256_hash'], unique: true },
    { fields: ['malware_family'] },
    { fields: ['threat_actor_id'] },
    { fields: ['analyst_id'] },
    { fields: ['analysis_status'] },
    { fields: ['first_seen'] },
    { fields: ['last_seen'] },
    { fields: ['severity'] },
    { fields: ['detection_ratio'] },
    { fields: ['created_at'] }
  ]
})
export class MalwareSample extends Model<MalwareSampleAttributes, MalwareSampleCreationAttributes> implements MalwareSampleAttributes {
  /** Unique identifier for the malware sample */
  @PrimaryKey
  @AutoIncrement
  @Column(DataType.INTEGER)
  declare id: number;

  /** Name of the malware sample */
  @AllowNull(false)
  @Length({ min: 1, max: 255 })
  @Column(DataType.STRING(255))
  declare name: string;

  /** MD5 hash of the file */
  @AllowNull(false)
  @Unique
  @Length({ min: 32, max: 32 })
  @Column(DataType.STRING(64))
  declare md5_hash: string;

  /** SHA1 hash of the file */
  @AllowNull(false)
  @Unique
  @Length({ min: 40, max: 40 })
  @Column(DataType.STRING(64))
  declare sha1_hash: string;

  /** SHA256 hash of the file */
  @AllowNull(false)
  @Unique
  @Length({ min: 64, max: 64 })
  @Column(DataType.STRING(64))
  declare sha256_hash: string;

  /** SHA512 hash of the file */
  @AllowNull(true)
  @Length({ min: 128, max: 128 })
  @Column(DataType.STRING(128))
  declare sha512_hash?: string;

  /** SSDEEP fuzzy hash */
  @AllowNull(true)
  @Column(DataType.STRING(255))
  declare ssdeep_hash?: string;

  /** File size in bytes */
  @AllowNull(true)
  @Column(DataType.BIGINT)
  declare file_size?: number;

  /** MIME type or file type */
  @AllowNull(true)
  @Length({ max: 100 })
  @Column(DataType.STRING(100))
  declare file_type?: string;

  /** Original filename when discovered */
  @AllowNull(true)
  @Length({ max: 255 })
  @Column(DataType.STRING(255))
  declare original_filename?: string;

  /** Malware family classification */
  @AllowNull(false)
  @Default('unknown')
  @Index
  @Length({ max: 100 })
  @Column(DataType.STRING(100))
  declare malware_family: string;

  /** Types of malware (Trojan, Ransomware, etc.) */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare malware_types: string[];

  /** Associated threat actor ID */
  @ForeignKey(() => ThreatActor)
  @AllowNull(true)
  @Index
  @Column(DataType.INTEGER)
  declare threat_actor_id?: number;

  /** Analyst who processed this sample */
  @ForeignKey(() => User)
  @AllowNull(true)
  @Index
  @Column(DataType.INTEGER)
  declare analyst_id?: number;

  /** Current analysis status */
  @AllowNull(false)
  @Default('pending')
  @Index
  @Column(DataType.ENUM('pending', 'analyzing', 'complete', 'failed', 'queued'))
  declare analysis_status: 'pending' | 'analyzing' | 'complete' | 'failed' | 'queued';

  /** When the sample was first observed */
  @AllowNull(true)
  @Index
  @Column(DataType.DATE)
  declare first_seen?: Date;

  /** When the sample was last observed */
  @AllowNull(true)
  @Index
  @Column(DataType.DATE)
  declare last_seen?: Date;

  /** Static analysis results */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare static_analysis: Record<string, any>;

  /** Dynamic analysis results */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare dynamic_analysis: Record<string, any>;

  /** Sandbox execution results */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare sandbox_results: Record<string, any>;

  /** YARA rules that matched */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare yara_rules_matched: string[];

  /** Network-based indicators */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare network_indicators: string[];

  /** File-based indicators */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare file_indicators: string[];

  /** Registry-based indicators */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare registry_indicators: string[];

  /** Behavioral indicators */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare behavioral_indicators: string[];

  /** Malware capabilities */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare capabilities: string[];

  /** Command and control domains */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare c2_domains: string[];

  /** Command and control IP addresses */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare c2_ips: string[];

  /** Files dropped by the malware */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare dropped_files: string[];

  /** Mutex names created */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare mutex_names: string[];

  /** Process names spawned */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare process_names: string[];

  /** Service names created */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare service_names: string[];

  /** Portable Executable file information */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare pe_info: Record<string, any>;

  /** String analysis results */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare strings_analysis: Record<string, any>;

  /** Import/Export analysis */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare imports_exports: Record<string, any>;

  /** Packer detection information */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare packer_info: Record<string, any>;

  /** Encryption analysis */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare encryption_info: Record<string, any>;

  /** Antivirus detection results */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare av_detections: Record<string, any>;

  /** Number of AV engines that detected */
  @AllowNull(false)
  @Default(0)
  @Index
  @Column(DataType.INTEGER)
  declare detection_ratio: number;

  /** Total number of AV engines scanned */
  @AllowNull(false)
  @Default(0)
  @Column(DataType.INTEGER)
  declare total_scanned: number;

  /** Severity level assessment */
  @AllowNull(false)
  @Default('medium')
  @Index
  @Column(DataType.ENUM('low', 'medium', 'high', 'critical'))
  declare severity: 'low' | 'medium' | 'high' | 'critical';

  /** Classification tags */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare tags: string[];

  /** Intelligence sources */
  @AllowNull(false)
  @Default([])
  @Column(DataType.ARRAY(DataType.STRING))
  declare sources: string[];

  /** Additional metadata */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare metadata: Record<string, any>;

  /** Record creation timestamp */
  @CreatedAt
  @Column(DataType.DATE)
  declare created_at: Date;

  /** Record last update timestamp */
  @UpdatedAt
  @Column(DataType.DATE)
  declare updated_at: Date;

  // Associations
  /** Associated threat actor */
  @BelongsTo(() => ThreatActor, {
    foreignKey: 'threat_actor_id',
    as: 'threat_actor',
    onDelete: 'SET NULL',
    onUpdate: 'CASCADE'
  })
  declare threat_actor?: ThreatActor;

  /** Analyst who processed this sample */
  @BelongsTo(() => User, {
    foreignKey: 'analyst_id',
    as: 'analyst',
    onDelete: 'SET NULL',
    onUpdate: 'CASCADE'
  })
  declare analyst?: User;

  /** Associated IOCs generated from this sample */
  @HasMany(() => IOC, {
    foreignKey: 'malware_sample_id',
    as: 'iocs',
    onDelete: 'CASCADE',
    onUpdate: 'CASCADE'
  })
  declare iocs?: IOC[];

  // Instance methods
  /**
   * Check if this malware sample is high risk
   * @returns True if critical/high severity or high detection ratio
   */
  public isHighRisk(): boolean {
    return this.severity === 'critical' || 
           this.severity === 'high' || 
           this.getDetectionPercentage() > 50;
  }

  /**
   * Get detection percentage from AV engines
   * @returns Percentage of AV engines that detected
   */
  public getDetectionPercentage(): number {
    if (this.total_scanned === 0) return 0;
    return Math.round((this.detection_ratio / this.total_scanned) * 100);
  }

  /**
   * Check if analysis is complete
   * @returns True if analysis status is complete
   */
  public isAnalyzed(): boolean {
    return this.analysis_status === 'complete';
  }

  /**
   * Check if analysis is pending or in progress
   * @returns True if analysis is not complete
   */
  public isPendingAnalysis(): boolean {
    return this.analysis_status === 'pending' || this.analysis_status === 'analyzing' || this.analysis_status === 'queued';
  }

  /**
   * Check if analysis failed
   * @returns True if analysis status is failed
   */
  public isAnalysisFailed(): boolean {
    return this.analysis_status === 'failed';
  }

  /**
   * Check if malware has C2 communication capabilities
   * @returns True if C2 domains or IPs are present
   */
  public hasC2Communication(): boolean {
    return this.c2_domains.length > 0 || this.c2_ips.length > 0;
  }

  /**
   * Check if the file is packed
   * @returns True if packer information is available
   */
  public isPacked(): boolean {
    return this.packer_info && Object.keys(this.packer_info).length > 0;
  }

  /**
   * Check if the file uses encryption
   * @returns True if encryption information is available
   */
  public isEncrypted(): boolean {
    return this.encryption_info && Object.keys(this.encryption_info).length > 0;
  }

  /**
   * Get severity level as numeric score
   * @returns Numeric score (1-4) based on severity
   */
  public getSeverityScore(): number {
    const scores: Record<string, number> = {
      'low': 1,
      'medium': 2,
      'high': 3,
      'critical': 4
    };
    return scores[this.severity] || 2;
  }

  /**
   * Get threat score combining multiple risk factors
   * @returns Combined threat score (0-10)
   */
  public getThreatScore(): number {
    let score = this.getSeverityScore() * 2; // Base score 2-8
    
    // Add bonus for high detection rate
    if (this.getDetectionPercentage() > 75) score += 2;
    else if (this.getDetectionPercentage() > 50) score += 1;
    
    // Add bonus for C2 communication
    if (this.hasC2Communication()) score += 1;
    
    // Add bonus for advanced capabilities
    if (this.capabilities.length > 5) score += 1;
    
    return Math.min(score, 10);
  }

  /**
   * Get file size in human-readable format
   * @returns Formatted file size string
   */
  public getFormattedFileSize(): string {
    if (!this.file_size) return 'Unknown';
    
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = this.file_size;
    let unitIndex = 0;
    
    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }
    
    return `${size.toFixed(1)} ${units[unitIndex]}`;
  }

  /**
   * Get age of sample in days
   * @returns Age in days since first seen
   */
  public getAge(): number {
    if (!this.first_seen) return 0;
    const diffTime = new Date().getTime() - this.first_seen.getTime();
    return Math.floor(diffTime / (1000 * 60 * 60 * 24));
  }

  /**
   * Get days since last seen
   * @returns Days since last observation
   */
  public getDaysSinceLastSeen(): number {
    if (!this.last_seen) return this.getAge();
    const diffTime = new Date().getTime() - this.last_seen.getTime();
    return Math.floor(diffTime / (1000 * 60 * 60 * 24));
  }

  /**
   * Check if sample is recent (within last 30 days)
   * @returns True if recently observed
   */
  public isRecent(): boolean {
    return this.getAge() <= 30 || this.getDaysSinceLastSeen() <= 30;
  }

  /**
   * Get all hash values as an object
   * @returns Object containing all available hashes
   */
  public getAllHashes(): {
    md5: string;
    sha1: string;
    sha256: string;
    sha512?: string | undefined;
    ssdeep?: string | undefined;
  } {
    return {
      md5: this.md5_hash,
      sha1: this.sha1_hash,
      sha256: this.sha256_hash,
      sha512: this.sha512_hash,
      ssdeep: this.ssdeep_hash
    };
  }

  /**
   * Mark sample as analyzed and update timestamp
   * @returns Promise resolving to updated sample
   */
  public async markAsAnalyzed(): Promise<this> {
    this.analysis_status = 'complete';
    this.last_seen = new Date();
    return this.save();
  }

  /**
   * Mark analysis as failed with optional error
   * @param error Optional error message
   * @returns Promise resolving to updated sample
   */
  public async markAnalysisFailed(error?: string): Promise<this> {
    this.analysis_status = 'failed';
    if (error) {
      this.metadata = { ...this.metadata, analysis_error: error };
    }
    return this.save();
  }

  /**
   * Update AV detection ratio
   * @param detected Number of engines that detected
   * @param total Total number of engines scanned
   * @returns Promise resolving to updated sample
   */
  public async updateDetectionRatio(detected: number, total: number): Promise<this> {
    this.detection_ratio = detected;
    this.total_scanned = total;
    return this.save();
  }

  /**
   * Add a capability to the malware
   * @param capability Capability to add
   * @returns Promise resolving to updated sample
   */
  public async addCapability(capability: string): Promise<this> {
    if (!this.capabilities.includes(capability)) {
      this.capabilities = [...this.capabilities, capability];
      return this.save();
    }
    return this;
  }

  /**
   * Add a tag to the sample
   * @param tag Tag to add
   * @returns Promise resolving to updated sample
   */
  public async addTag(tag: string): Promise<this> {
    if (!this.tags.includes(tag)) {
      this.tags = [...this.tags, tag];
      return this.save();
    }
    return this;
  }

  /**
   * Remove a tag from the sample
   * @param tag Tag to remove
   * @returns Promise resolving to updated sample
   */
  public async removeTag(tag: string): Promise<this> {
    this.tags = this.tags.filter(t => t !== tag);
    return this.save();
  }

  // Static methods
  /**
   * Find malware sample by any hash value
   * @param hash Hash value to search for
   * @returns Promise resolving to sample or null
   */
  static async findByHash(hash: string): Promise<MalwareSample | null> {
    const normalizedHash = hash.toLowerCase();
    return this.findOne({
      where: {
        [Op.or]: [
          { md5_hash: normalizedHash },
          { sha1_hash: normalizedHash },
          { sha256_hash: normalizedHash },
          { sha512_hash: normalizedHash }
        ]
      }
    });
  }

  /**
   * Find samples by malware family
   * @param family Malware family name
   * @returns Promise resolving to samples in family
   */
  static async findByFamily(family: string): Promise<MalwareSample[]> {
    return this.findAll({
      where: { malware_family: { [Op.iLike]: `%${family}%` } },
      order: [['last_seen', 'DESC']]
    });
  }

  /**
   * Find samples by threat actor
   * @param threatActorId Threat actor ID
   * @returns Promise resolving to samples by threat actor
   */
  static async findByThreatActor(threatActorId: number): Promise<MalwareSample[]> {
    return this.findAll({
      where: { threat_actor_id: threatActorId },
      order: [['last_seen', 'DESC']]
    });
  }

  /**
   * Find samples by analyst
   * @param analystId Analyst user ID
   * @returns Promise resolving to samples processed by analyst
   */
  static async findByAnalyst(analystId: number): Promise<MalwareSample[]> {
    return this.findAll({
      where: { analyst_id: analystId },
      order: [['created_at', 'DESC']]
    });
  }

  /**
   * Find high-risk samples
   * @returns Promise resolving to high-risk samples
   */
  static async findHighRisk(): Promise<MalwareSample[]> {
    return this.findAll({
      where: {
        [Op.or]: [
          { severity: { [Op.in]: ['high', 'critical'] } },
          { 
            [Op.and]: [
              { detection_ratio: { [Op.gt]: 0 } },
              { total_scanned: { [Op.gt]: 0 } },
              this.sequelize!.where(
                this.sequelize!.literal('(detection_ratio::float / total_scanned::float) * 100'),
                { [Op.gt]: 50 }
              )
            ]
          }
        ]
      },
      order: [['severity', 'DESC'], ['detection_ratio', 'DESC']]
    });
  }

  /**
   * Find recent samples within specified days
   * @param days Number of days to look back (default: 7)
   * @returns Promise resolving to recent samples
   */
  static async findRecent(days: number = 7): Promise<MalwareSample[]> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    
    return this.findAll({
      where: {
        [Op.or]: [
          { first_seen: { [Op.gte]: cutoffDate } },
          { last_seen: { [Op.gte]: cutoffDate } }
        ]
      },
      order: [['last_seen', 'DESC']]
    });
  }

  /**
   * Find samples with C2 communication capabilities
   * @returns Promise resolving to samples with C2
   */
  static async findWithC2(): Promise<MalwareSample[]> {
    return this.findAll({
      where: {
        [Op.or]: [
          { c2_domains: { [Op.ne]: [] } },
          { c2_ips: { [Op.ne]: [] } }
        ]
      },
      order: [['last_seen', 'DESC']]
    });
  }

  /**
   * Find samples by YARA rule match
   * @param ruleName YARA rule name
   * @returns Promise resolving to matching samples
   */
  static async findByYaraRule(ruleName: string): Promise<MalwareSample[]> {
    return this.findAll({
      where: {
        yara_rules_matched: { [Op.contains]: [ruleName] }
      },
      order: [['last_seen', 'DESC']]
    });
  }

  /**
   * Find samples by malware type
   * @param type Malware type (e.g., 'Trojan', 'Ransomware')
   * @returns Promise resolving to samples of specified type
   */
  static async findByType(type: string): Promise<MalwareSample[]> {
    return this.findAll({
      where: {
        malware_types: { [Op.contains]: [type] }
      },
      order: [['last_seen', 'DESC']]
    });
  }

  /**
   * Find samples pending analysis
   * @returns Promise resolving to pending samples
   */
  static async findPendingAnalysis(): Promise<MalwareSample[]> {
    return this.findAll({
      where: { 
        analysis_status: { [Op.in]: ['pending', 'analyzing', 'queued'] } 
      },
      order: [['created_at', 'ASC']]
    });
  }

  /**
   * Find samples by analysis status
   * @param status Analysis status to filter by
   * @returns Promise resolving to samples with specified status
   */
  static async findByAnalysisStatus(status: MalwareSampleAttributes['analysis_status']): Promise<MalwareSample[]> {
    return this.findAll({
      where: { analysis_status: status },
      order: [['created_at', 'DESC']]
    });
  }

  /**
   * Find samples by severity level
   * @param severity Severity level to filter by
   * @returns Promise resolving to samples with specified severity
   */
  static async findBySeverity(severity: MalwareSampleAttributes['severity']): Promise<MalwareSample[]> {
    return this.findAll({
      where: { severity },
      order: [['last_seen', 'DESC']]
    });
  }

  /**
   * Find packed samples
   * @returns Promise resolving to packed samples
   */
  static async findPacked(): Promise<MalwareSample[]> {
    return this.findAll({
      where: {
        packer_info: { [Op.ne]: '{}' }
      },
      order: [['last_seen', 'DESC']]
    });
  }

  /**
   * Search samples by name or filename
   * @param query Search query
   * @returns Promise resolving to matching samples
   */
  static async searchSamples(query: string): Promise<MalwareSample[]> {
    return this.findAll({
      where: {
        [Op.or]: [
          { name: { [Op.iLike]: `%${query}%` } },
          { original_filename: { [Op.iLike]: `%${query}%` } },
          { malware_family: { [Op.iLike]: `%${query}%` } }
        ]
      },
      order: [['last_seen', 'DESC']]
    });
  }

  /**
   * Get malware family distribution statistics
   * @returns Promise resolving to family statistics
   */
  static async getFamilyStats(): Promise<Array<{ family: string; count: number }>> {
    const results = await this.findAll({
      attributes: [
        'malware_family',
        [this.sequelize!.fn('COUNT', this.sequelize!.col('id')), 'count']
      ],
      group: ['malware_family'],
      order: [[this.sequelize!.fn('COUNT', this.sequelize!.col('id')), 'DESC']]
    });
    
    return results.map(r => ({
      family: r.malware_family,
      count: parseInt((r as any).getDataValue('count'))
    }));
  }

  /**
   * Get malware type distribution statistics
   * @returns Promise resolving to type statistics
   */
  static async getTypeStats(): Promise<Array<{ type: string; count: number }>> {
    const samples = await this.findAll({
      attributes: ['malware_types']
    });
    
    const typeCounts: Record<string, number> = {};
    samples.forEach(sample => {
      sample.malware_types.forEach(type => {
        typeCounts[type] = (typeCounts[type] || 0) + 1;
      });
    });
    
    return Object.entries(typeCounts)
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count);
  }

  /**
   * Get severity distribution statistics
   * @returns Promise resolving to severity statistics
   */
  static async getSeverityStats(): Promise<Array<{ severity: string; count: number }>> {
    const results = await this.findAll({
      attributes: [
        'severity',
        [this.sequelize!.fn('COUNT', this.sequelize!.col('id')), 'count']
      ],
      group: ['severity']
    });
    
    return results.map(r => ({
      severity: r.severity,
      count: parseInt((r as any).getDataValue('count'))
    }));
  }

  /**
   * Get analysis status distribution statistics
   * @returns Promise resolving to status statistics
   */
  static async getAnalysisStatusStats(): Promise<Array<{ status: string; count: number }>> {
    const results = await this.findAll({
      attributes: [
        'analysis_status',
        [this.sequelize!.fn('COUNT', this.sequelize!.col('id')), 'count']
      ],
      group: ['analysis_status']
    });
    
    return results.map(r => ({
      status: r.analysis_status,
      count: parseInt((r as any).getDataValue('count'))
    }));
  }

  /**
   * Get comprehensive detection statistics
   * @returns Promise resolving to detection statistics
   */
  static async getDetectionStats(): Promise<{
    total_samples: number;
    analyzed_samples: number;
    high_detection: number;
    with_c2: number;
    packed_samples: number;
    recent_samples: number;
  }> {
    const [
      totalSamples,
      analyzedSamples,
      highDetectionSamples,
      samplesWithC2,
      packedSamples,
      recentSamples
    ] = await Promise.all([
      this.count(),
      this.count({ where: { analysis_status: 'complete' } }),
      this.count({
        where: {
          [Op.and]: [
            { detection_ratio: { [Op.gt]: 0 } },
            { total_scanned: { [Op.gt]: 0 } },
            this.sequelize!.where(
              this.sequelize!.literal('(detection_ratio::float / total_scanned::float) * 100'),
              { [Op.gt]: 50 }
            )
          ]
        }
      }),
      this.count({
        where: {
          [Op.or]: [
            { c2_domains: { [Op.ne]: [] } },
            { c2_ips: { [Op.ne]: [] } }
          ]
        }
      }),
      this.count({
        where: {
          packer_info: { [Op.ne]: '{}' }
        }
      }),
      this.count({
        where: {
          created_at: {
            [Op.gte]: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
          }
        }
      })
    ]);

    return {
      total_samples: totalSamples,
      analyzed_samples: analyzedSamples,
      high_detection: highDetectionSamples,
      with_c2: samplesWithC2,
      packed_samples: packedSamples,
      recent_samples: recentSamples
    };
  }

  /**
   * Get trend data over time
   * @param days Number of days to analyze (default: 30)
   * @returns Promise resolving to trend data
   */
  static async getTrendStats(days: number = 30): Promise<Array<{ date: string; count: number }>> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    
    const results = await this.findAll({
      attributes: [
        [this.sequelize!.fn('DATE', this.sequelize!.col('created_at')), 'date'],
        [this.sequelize!.fn('COUNT', this.sequelize!.col('id')), 'count']
      ],
      where: {
        created_at: { [Op.gte]: cutoffDate }
      },
      group: [this.sequelize!.fn('DATE', this.sequelize!.col('created_at'))],
      order: [[this.sequelize!.fn('DATE', this.sequelize!.col('created_at')), 'ASC']]
    });
    
    return results.map(r => ({
      date: (r as any).getDataValue('date'),
      count: parseInt((r as any).getDataValue('count'))
    }));
  }

  /**
   * Create malware sample with validation
   * @param data Sample data to create
   * @returns Promise resolving to created sample
   */
  static async createSample(data: MalwareSampleCreationAttributes): Promise<MalwareSample> {
    // Validate hash formats
    if (!/^[a-fA-F0-9]{32}$/.test(data.md5_hash)) {
      throw new Error('Invalid MD5 hash format');
    }
    if (!/^[a-fA-F0-9]{40}$/.test(data.sha1_hash)) {
      throw new Error('Invalid SHA1 hash format');
    }
    if (!/^[a-fA-F0-9]{64}$/.test(data.sha256_hash)) {
      throw new Error('Invalid SHA256 hash format');
    }

    // Check for duplicate samples
    const existing = await this.findByHash(data.sha256_hash);
    if (existing) {
      throw new Error(`Sample with SHA256 ${data.sha256_hash} already exists`);
    }

    // Set timestamps if not provided
    if (!data.first_seen) {
      data.first_seen = new Date();
    }
    if (!data.last_seen) {
      data.last_seen = new Date();
    }

    return this.create(data);
  }
}

export default MalwareSample;
