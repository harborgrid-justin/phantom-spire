/**
 * VULNERABILITY ASSESSMENT SEQUELIZE MODEL
 * Represents vulnerability assessments and scans with comprehensive type safety
 */
import {
  Table,
  Column,
  Model,
  PrimaryKey,
  AutoIncrement,
  AllowNull,
  Default,
  CreatedAt,
  UpdatedAt,
  BelongsTo,
  ForeignKey,
  DataType,
  Index,
  Length
} from 'sequelize-typescript';
import { Optional } from 'sequelize';
import { Op } from 'sequelize';
import { User } from './User.model';

// VulnerabilityAssessment Attributes Interface
export interface VulnerabilityAssessmentAttributes {
  /** Unique identifier for the vulnerability assessment */
  id: number;
  /** Name of the vulnerability assessment */
  assessment_name: string;
  /** Description of the assessment scope and objectives */
  description?: string;
  /** Target of the assessment (IP, domain, network range) */
  target: string;
  /** Current status of the assessment */
  status: 'scheduled' | 'running' | 'completed' | 'failed' | 'cancelled';
  /** User ID of the assessor */
  assessor_id?: number;
  /** When the scan started */
  scan_start?: Date;
  /** When the scan completed */
  scan_end?: Date;
  /** Number of critical severity vulnerabilities */
  critical_vulnerabilities: number;
  /** Number of high severity vulnerabilities */
  high_vulnerabilities: number;
  /** Number of medium severity vulnerabilities */
  medium_vulnerabilities: number;
  /** Number of low severity vulnerabilities */
  low_vulnerabilities: number;
  /** Detailed scan results and findings */
  scan_results: Record<string, any>;
  /** Remediation plan and recommendations */
  remediation_plan: Record<string, any>;
  /** Additional metadata */
  metadata: Record<string, any>;
  /** Record creation timestamp */
  created_at: Date;
  /** Record last update timestamp */
  updated_at: Date;
}

// VulnerabilityAssessment Creation Attributes Interface
export interface VulnerabilityAssessmentCreationAttributes extends Optional<VulnerabilityAssessmentAttributes,
  'id' | 'description' | 'status' | 'assessor_id' | 'scan_start' | 'scan_end' | 
  'critical_vulnerabilities' | 'high_vulnerabilities' | 'medium_vulnerabilities' | 
  'low_vulnerabilities' | 'scan_results' | 'remediation_plan' | 'metadata' | 
  'created_at' | 'updated_at'
> {}

@Table({
  tableName: 'vulnerability_assessments',
  timestamps: true,
  underscored: true,
  paranoid: false,
  indexes: [
    { fields: ['assessment_name'] },
    { fields: ['target'] },
    { fields: ['status'] },
    { fields: ['assessor_id'] },
    { fields: ['scan_start'] },
    { fields: ['scan_end'] },
    { fields: ['critical_vulnerabilities'] },
    { fields: ['created_at'] }
  ]
})
export class VulnerabilityAssessment extends Model<VulnerabilityAssessmentAttributes, VulnerabilityAssessmentCreationAttributes> implements VulnerabilityAssessmentAttributes {
  /** Unique identifier for the vulnerability assessment */
  @PrimaryKey
  @AutoIncrement
  @Column(DataType.INTEGER)
  declare id: number;

  /** Name of the vulnerability assessment */
  @AllowNull(false)
  @Length({ min: 1, max: 255 })
  @Column(DataType.STRING(255))
  declare assessment_name: string;

  /** Description of the assessment scope and objectives */
  @AllowNull(true)
  @Column(DataType.TEXT)
  declare description?: string;

  /** Target of the assessment (IP, domain, network range) */
  @AllowNull(false)
  @Index
  @Length({ min: 1, max: 255 })
  @Column(DataType.STRING(255))
  declare target: string;

  /** Current status of the assessment */
  @AllowNull(false)
  @Default('scheduled')
  @Index
  @Column(DataType.ENUM('scheduled', 'running', 'completed', 'failed', 'cancelled'))
  declare status: 'scheduled' | 'running' | 'completed' | 'failed' | 'cancelled';

  /** User ID of the assessor */
  @ForeignKey(() => User)
  @AllowNull(true)
  @Column(DataType.INTEGER)
  declare assessor_id?: number;

  /** When the scan started */
  @AllowNull(true)
  @Index
  @Column(DataType.DATE)
  declare scan_start?: Date;

  /** When the scan completed */
  @AllowNull(true)
  @Index
  @Column(DataType.DATE)
  declare scan_end?: Date;

  /** Number of critical severity vulnerabilities */
  @AllowNull(false)
  @Default(0)
  @Index
  @Column(DataType.INTEGER)
  declare critical_vulnerabilities: number;

  /** Number of high severity vulnerabilities */
  @AllowNull(false)
  @Default(0)
  @Column(DataType.INTEGER)
  declare high_vulnerabilities: number;

  /** Number of medium severity vulnerabilities */
  @AllowNull(false)
  @Default(0)
  @Column(DataType.INTEGER)
  declare medium_vulnerabilities: number;

  /** Number of low severity vulnerabilities */
  @AllowNull(false)
  @Default(0)
  @Column(DataType.INTEGER)
  declare low_vulnerabilities: number;

  /** Detailed scan results and findings */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare scan_results: Record<string, any>;

  /** Remediation plan and recommendations */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare remediation_plan: Record<string, any>;

  /** Additional metadata */
  @AllowNull(false)
  @Default('{}')
  @Column(DataType.JSONB)
  declare metadata: Record<string, any>;

  /** Record creation timestamp */
  @CreatedAt
  @Column(DataType.DATE)
  declare created_at: Date;

  /** Record last update timestamp */
  @UpdatedAt
  @Column(DataType.DATE)
  declare updated_at: Date;

  // Associations
  /** User who performed the assessment */
  @BelongsTo(() => User, {
    foreignKey: 'assessor_id',
    as: 'assessor',
    onDelete: 'SET NULL',
    onUpdate: 'CASCADE'
  })
  declare assessor?: User;

  // Instance methods
  /**
   * Get total number of vulnerabilities across all severities
   * @returns Total vulnerability count
   */
  public getTotalVulnerabilities(): number {
    return this.critical_vulnerabilities + this.high_vulnerabilities + 
           this.medium_vulnerabilities + this.low_vulnerabilities;
  }

  /**
   * Calculate risk score based on vulnerability severity weights
   * @returns Weighted risk score
   */
  public getRiskScore(): number {
    return (this.critical_vulnerabilities * 10) + 
           (this.high_vulnerabilities * 5) + 
           (this.medium_vulnerabilities * 2) + 
           (this.low_vulnerabilities * 1);
  }

  /**
   * Get risk level based on critical and high vulnerabilities
   * @returns Risk level classification
   */
  public getRiskLevel(): 'critical' | 'high' | 'medium' | 'low' {
    if (this.critical_vulnerabilities > 0) return 'critical';
    if (this.high_vulnerabilities > 5) return 'high';
    if (this.high_vulnerabilities > 0 || this.medium_vulnerabilities > 10) return 'medium';
    return 'low';
  }

  /**
   * Check if assessment is currently running
   * @returns True if status is running
   */
  public isRunning(): boolean {
    return this.status === 'running';
  }

  /**
   * Check if assessment is completed
   * @returns True if status is completed
   */
  public isCompleted(): boolean {
    return this.status === 'completed';
  }

  /**
   * Check if assessment failed
   * @returns True if status is failed
   */
  public isFailed(): boolean {
    return this.status === 'failed';
  }

  /**
   * Check if assessment was cancelled
   * @returns True if status is cancelled
   */
  public isCancelled(): boolean {
    return this.status === 'cancelled';
  }

  /**
   * Check if assessment has high-priority vulnerabilities
   * @returns True if critical or high vulnerabilities exist
   */
  public hasHighPriorityVulnerabilities(): boolean {
    return this.critical_vulnerabilities > 0 || this.high_vulnerabilities > 0;
  }

  /**
   * Get scan duration in minutes
   * @returns Duration in minutes, or null if not available
   */
  public getScanDurationMinutes(): number | null {
    if (!this.scan_start || !this.scan_end) return null;
    const diffMs = this.scan_end.getTime() - this.scan_start.getTime();
    return Math.round(diffMs / (1000 * 60));
  }

  /**
   * Get age of assessment in days
   * @returns Age in days since creation
   */
  public getAge(): number {
    const diffTime = new Date().getTime() - this.created_at.getTime();
    return Math.floor(diffTime / (1000 * 60 * 60 * 24));
  }

  /**
   * Get days since scan completion
   * @returns Days since completion, or null if not completed
   */
  public getDaysSinceCompletion(): number | null {
    if (!this.scan_end) return null;
    const diffTime = new Date().getTime() - this.scan_end.getTime();
    return Math.floor(diffTime / (1000 * 60 * 60 * 24));
  }

  /**
   * Check if assessment results are stale
   * @param days Number of days to consider stale (default: 30)
   * @returns True if assessment is older than specified days
   */
  public isStale(days: number = 30): boolean {
    const daysSinceCompletion = this.getDaysSinceCompletion();
    return daysSinceCompletion !== null && daysSinceCompletion > days;
  }

  /**
   * Start the assessment scan
   * @returns Promise resolving to updated assessment
   */
  public async startScan(): Promise<this> {
    this.status = 'running';
    this.scan_start = new Date();
    return this.save();
  }

  /**
   * Complete the assessment scan
   * @returns Promise resolving to updated assessment
   */
  public async completeScan(): Promise<this> {
    this.status = 'completed';
    this.scan_end = new Date();
    return this.save();
  }

  /**
   * Mark assessment as failed
   * @param errorMessage Optional error message to store
   * @returns Promise resolving to updated assessment
   */
  public async markFailed(errorMessage?: string): Promise<this> {
    this.status = 'failed';
    this.scan_end = new Date();
    if (errorMessage) {
      this.metadata = { ...this.metadata, error: errorMessage };
    }
    return this.save();
  }

  /**
   * Cancel the assessment
   * @returns Promise resolving to updated assessment
   */
  public async cancel(): Promise<this> {
    this.status = 'cancelled';
    if (this.scan_start && !this.scan_end) {
      this.scan_end = new Date();
    }
    return this.save();
  }

  /**
   * Update vulnerability counts
   * @param counts Object containing vulnerability counts by severity
   * @returns Promise resolving to updated assessment
   */
  public async updateVulnerabilityCounts(counts: {
    critical?: number;
    high?: number;
    medium?: number;
    low?: number;
  }): Promise<this> {
    if (counts.critical !== undefined) this.critical_vulnerabilities = counts.critical;
    if (counts.high !== undefined) this.high_vulnerabilities = counts.high;
    if (counts.medium !== undefined) this.medium_vulnerabilities = counts.medium;
    if (counts.low !== undefined) this.low_vulnerabilities = counts.low;
    return this.save();
  }

  // Static methods
  /**
   * Find assessments by target
   * @param target Target to search for
   * @returns Promise resolving to assessments for target
   */
  static async findByTarget(target: string): Promise<VulnerabilityAssessment[]> {
    return this.findAll({
      where: { target },
      order: [['scan_start', 'DESC']]
    });
  }

  /**
   * Find assessments by status
   * @param status Status to filter by
   * @returns Promise resolving to assessments with specified status
   */
  static async findByStatus(status: VulnerabilityAssessmentAttributes['status']): Promise<VulnerabilityAssessment[]> {
    return this.findAll({
      where: { status },
      order: [['created_at', 'DESC']]
    });
  }

  /**
   * Find assessments by assessor
   * @param assessorId Assessor user ID
   * @returns Promise resolving to assessments by assessor
   */
  static async findByAssessor(assessorId: number): Promise<VulnerabilityAssessment[]> {
    return this.findAll({
      where: { assessor_id: assessorId },
      order: [['created_at', 'DESC']]
    });
  }

  /**
   * Find high-risk assessments (with critical vulnerabilities)
   * @returns Promise resolving to high-risk assessments
   */
  static async findHighRisk(): Promise<VulnerabilityAssessment[]> {
    return this.findAll({
      where: { 
        critical_vulnerabilities: { [Op.gt]: 0 },
        status: 'completed'
      },
      order: [['critical_vulnerabilities', 'DESC']]
    });
  }

  /**
   * Find assessments with high-priority vulnerabilities
   * @returns Promise resolving to assessments with critical or high severity vulnerabilities
   */
  static async findWithHighPriorityVulnerabilities(): Promise<VulnerabilityAssessment[]> {
    return this.findAll({
      where: {
        [Op.or]: [
          { critical_vulnerabilities: { [Op.gt]: 0 } },
          { high_vulnerabilities: { [Op.gt]: 0 } }
        ],
        status: 'completed'
      },
      order: [['critical_vulnerabilities', 'DESC'], ['high_vulnerabilities', 'DESC']]
    });
  }

  /**
   * Find recent assessments within specified days
   * @param days Number of days to look back (default: 30)
   * @returns Promise resolving to recent assessments
   */
  static async findRecent(days: number = 30): Promise<VulnerabilityAssessment[]> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    
    return this.findAll({
      where: {
        created_at: { [Op.gte]: cutoffDate }
      },
      order: [['created_at', 'DESC']]
    });
  }

  /**
   * Find stale assessments (completed assessments older than specified days)
   * @param days Number of days to consider stale (default: 30)
   * @returns Promise resolving to stale assessments
   */
  static async findStale(days: number = 30): Promise<VulnerabilityAssessment[]> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    
    return this.findAll({
      where: {
        scan_end: { [Op.lt]: cutoffDate },
        status: 'completed'
      },
      order: [['scan_end', 'ASC']]
    });
  }

  /**
   * Find running assessments that may be stuck
   * @param hours Number of hours to consider stuck (default: 24)
   * @returns Promise resolving to potentially stuck assessments
   */
  static async findPotentiallyStuck(hours: number = 24): Promise<VulnerabilityAssessment[]> {
    const cutoffDate = new Date();
    cutoffDate.setHours(cutoffDate.getHours() - hours);
    
    return this.findAll({
      where: {
        status: 'running',
        scan_start: { [Op.lt]: cutoffDate }
      },
      order: [['scan_start', 'ASC']]
    });
  }

  /**
   * Search assessments by name or target
   * @param query Search query
   * @returns Promise resolving to matching assessments
   */
  static async searchAssessments(query: string): Promise<VulnerabilityAssessment[]> {
    return this.findAll({
      where: {
        [Op.or]: [
          { assessment_name: { [Op.iLike]: `%${query}%` } },
          { target: { [Op.iLike]: `%${query}%` } },
          { description: { [Op.iLike]: `%${query}%` } }
        ]
      },
      order: [['created_at', 'DESC']]
    });
  }

  /**
   * Get assessment statistics by status
   * @returns Promise resolving to status statistics
   */
  static async getStatusStats(): Promise<Array<{ status: string; count: number }>> {
    const results = await this.findAll({
      attributes: [
        'status',
        [this.sequelize!.fn('COUNT', this.sequelize!.col('id')), 'count']
      ],
      group: ['status']
    });
    
    return results.map(r => ({
      status: r.status,
      count: parseInt((r as any).getDataValue('count'))
    }));
  }

  /**
   * Get vulnerability distribution statistics
   * @returns Promise resolving to vulnerability statistics
   */
  static async getVulnerabilityStats(): Promise<{
    total_assessments: number;
    total_critical: number;
    total_high: number;
    total_medium: number;
    total_low: number;
    avg_risk_score: number;
  }> {
    const results = await this.findAll({
      attributes: [
        [this.sequelize!.fn('COUNT', this.sequelize!.col('id')), 'total_assessments'],
        [this.sequelize!.fn('SUM', this.sequelize!.col('critical_vulnerabilities')), 'total_critical'],
        [this.sequelize!.fn('SUM', this.sequelize!.col('high_vulnerabilities')), 'total_high'],
        [this.sequelize!.fn('SUM', this.sequelize!.col('medium_vulnerabilities')), 'total_medium'],
        [this.sequelize!.fn('SUM', this.sequelize!.col('low_vulnerabilities')), 'total_low'],
        [this.sequelize!.fn('AVG', 
          this.sequelize!.literal('(critical_vulnerabilities * 10 + high_vulnerabilities * 5 + medium_vulnerabilities * 2 + low_vulnerabilities)')
        ), 'avg_risk_score']
      ],
      where: { status: 'completed' }
    });

    const result = results[0];
    return {
      total_assessments: parseInt((result as any).getDataValue('total_assessments')) || 0,
      total_critical: parseInt((result as any).getDataValue('total_critical')) || 0,
      total_high: parseInt((result as any).getDataValue('total_high')) || 0,
      total_medium: parseInt((result as any).getDataValue('total_medium')) || 0,
      total_low: parseInt((result as any).getDataValue('total_low')) || 0,
      avg_risk_score: parseFloat((result as any).getDataValue('avg_risk_score')) || 0
    };
  }

  /**
   * Get assessment trend data over time
   * @param days Number of days to analyze (default: 30)
   * @returns Promise resolving to trend data
   */
  static async getTrendStats(days: number = 30): Promise<Array<{ date: string; count: number }>> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    
    const results = await this.findAll({
      attributes: [
        [this.sequelize!.fn('DATE', this.sequelize!.col('created_at')), 'date'],
        [this.sequelize!.fn('COUNT', this.sequelize!.col('id')), 'count']
      ],
      where: {
        created_at: { [Op.gte]: cutoffDate }
      },
      group: [this.sequelize!.fn('DATE', this.sequelize!.col('created_at'))],
      order: [[this.sequelize!.fn('DATE', this.sequelize!.col('created_at')), 'ASC']]
    });
    
    return results.map(r => ({
      date: (r as any).getDataValue('date'),
      count: parseInt((r as any).getDataValue('count'))
    }));
  }

  /**
   * Get top targets by vulnerability count
   * @param limit Maximum number of targets to return
   * @returns Promise resolving to top targets
   */
  static async getTopTargetsByRisk(limit: number = 10): Promise<Array<{
    target: string;
    assessment_count: number;
    total_critical: number;
    total_high: number;
    avg_risk_score: number;
  }>> {
    const results = await this.findAll({
      attributes: [
        'target',
        [this.sequelize!.fn('COUNT', this.sequelize!.col('id')), 'assessment_count'],
        [this.sequelize!.fn('SUM', this.sequelize!.col('critical_vulnerabilities')), 'total_critical'],
        [this.sequelize!.fn('SUM', this.sequelize!.col('high_vulnerabilities')), 'total_high'],
        [this.sequelize!.fn('AVG', 
          this.sequelize!.literal('(critical_vulnerabilities * 10 + high_vulnerabilities * 5 + medium_vulnerabilities * 2 + low_vulnerabilities)')
        ), 'avg_risk_score']
      ],
      where: { status: 'completed' },
      group: ['target'],
      order: [[this.sequelize!.fn('AVG', 
        this.sequelize!.literal('(critical_vulnerabilities * 10 + high_vulnerabilities * 5 + medium_vulnerabilities * 2 + low_vulnerabilities)')
      ), 'DESC']],
      limit
    });
    
    return results.map(r => ({
      target: r.target,
      assessment_count: parseInt((r as any).getDataValue('assessment_count')),
      total_critical: parseInt((r as any).getDataValue('total_critical')) || 0,
      total_high: parseInt((r as any).getDataValue('total_high')) || 0,
      avg_risk_score: parseFloat((r as any).getDataValue('avg_risk_score')) || 0
    }));
  }

  /**
   * Create vulnerability assessment with validation
   * @param data Assessment data to create
   * @returns Promise resolving to created assessment
   */
  static async createAssessment(data: VulnerabilityAssessmentCreationAttributes): Promise<VulnerabilityAssessment> {
    // Validate target format
    if (!data.target || data.target.trim().length === 0) {
      throw new Error('Target cannot be empty');
    }

    // Validate vulnerability counts
    if (data.critical_vulnerabilities && data.critical_vulnerabilities < 0) {
      throw new Error('Vulnerability counts cannot be negative');
    }

    return this.create(data);
  }
}

export default VulnerabilityAssessment;
