use crate::types::*;
use async_trait::async_trait;
use dashmap::DashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::Utc;
use std::collections::HashMap;
use napi_derive::napi;

#[async_trait]
pub trait VulnerabilityScanningTrait {
    async fn start_scan(&self, scan_config: VulnerabilityScanConfig) -> VulnerabilityScanResult;
    async fn assess_vulnerability(&self, vuln_data: VulnerabilityData) -> VulnerabilityAssessment;
    async fn generate_report(&self, scan_id: &str) -> Option<VulnerabilityReport>;
    async fn get_status(&self) -> ComponentStatus;
}

#[derive(Clone)]
pub struct VulnerabilityScanningEngine {
    scan_configurations: Arc<DashMap<String, VulnerabilityScanConfig>>,
    scan_results: Arc<DashMap<String, VulnerabilityScanResult>>,
    vulnerabilities: Arc<DashMap<String, VulnerabilityData>>,
    scan_profiles: Arc<DashMap<String, ScanProfile>>,
    processed_scans: Arc<RwLock<u64>>,
    critical_vulnerabilities: Arc<RwLock<u32>>,
    last_error: Arc<RwLock<Option<String>>>,
}

#[napi(object)]
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct VulnerabilityScanConfig {
    pub scan_id: String,
    pub name: String,
    pub scan_type: String, // "network", "web_application", "database", "infrastructure", "comprehensive"
    pub target_specification: String, // IP ranges, URLs, or asset groups
    pub scan_profile: String, // Profile ID for scan configuration
    pub scheduled: bool,
    pub schedule_expression: Option<String>, // Cron expression
    pub notification_settings: String, // JSON notification config
    pub compliance_frameworks: Vec<String>, // "PCI", "SOX", "HIPAA", etc.
    pub scan_depth: String, // "basic", "standard", "comprehensive", "intrusive"
    pub port_range: String, // "common", "full", "custom:1-1000"
    pub authentication_required: bool,
    pub credentials_vault_id: Option<String>,
}

#[napi(object)]
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ScanProfile {
    pub profile_id: String,
    pub name: String,
    pub description: String,
    pub scan_techniques: Vec<String>, // "port_scan", "service_detection", "version_detection", "script_scan"
    pub vulnerability_checks: Vec<String>, // Categories of vulnerability checks
    pub performance_settings: String, // JSON config for timing, threads, etc.
    pub evasion_techniques: Vec<String>, // "fragmentation", "decoy", "timing"
    pub output_formats: Vec<String>, // "json", "xml", "pdf", "csv"
    pub created_by: String,
    pub created_time: i64,
}

#[napi(object)]
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct VulnerabilityData {
    pub vulnerability_id: String,
    pub cve_id: Option<String>,
    pub title: String,
    pub description: String,
    pub severity: String, // "info", "low", "medium", "high", "critical"
    pub cvss_score: f64, // 0.0 to 10.0
    pub cvss_vector: Option<String>,
    pub category: String, // "injection", "broken_auth", "sensitive_data", "xxe", etc.
    pub affected_component: String,
    pub service: String,
    pub port: u16,
    pub protocol: String,
    pub discovery_method: String,
    pub proof_of_concept: Option<String>,
    pub references: Vec<String>, // URLs to vulnerability information
    pub first_detected: i64,
    pub last_verified: i64,
    pub scan_id: String,
    pub target: String,
}

#[napi(object)]
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct VulnerabilityScanResult {
    pub scan_id: String,
    pub scan_name: String,
    pub status: String, // "running", "completed", "failed", "cancelled"
    pub start_time: i64,
    pub end_time: Option<i64>,
    pub targets_scanned: u32,
    pub hosts_discovered: u32,
    pub services_identified: u32,
    pub vulnerabilities_found: u32,
    pub critical_count: u32,
    pub high_count: u32,
    pub medium_count: u32,
    pub low_count: u32,
    pub info_count: u32,
    pub scan_duration: i64, // seconds
    pub scan_coverage: f64, // percentage
    pub compliance_status: String, // JSON compliance check results
    pub top_vulnerabilities: Vec<String>, // Top CVE IDs found
}

#[napi(object)]
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct VulnerabilityAssessment {
    pub assessment_id: String,
    pub vulnerability_id: String,
    pub risk_score: f64, // 0.0 to 10.0
    pub exploitability: String, // "proof_of_concept", "functional", "high", "not_defined"
    pub impact_analysis: String,
    pub affected_assets: Vec<String>,
    pub business_impact: String, // "low", "medium", "high", "critical"
    pub remediation_priority: String, // "immediate", "high", "medium", "low"
    pub remediation_effort: String, // "minimal", "moderate", "significant", "extensive"
    pub remediation_recommendations: Vec<String>,
    pub compensating_controls: Vec<String>,
    pub false_positive_likelihood: f64, // 0.0 to 1.0
    pub assessment_date: i64,
    pub assessed_by: String,
}

#[napi(object)]
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct VulnerabilityReport {
    pub report_id: String,
    pub scan_id: String,
    pub report_type: String, // "executive", "technical", "compliance", "trending"
    pub generation_time: i64,
    pub report_period: String,
    pub executive_summary: String,
    pub scan_summary: VulnerabilityScanResult,
    pub vulnerability_breakdown: VulnerabilityBreakdown,
    pub risk_analysis: String,
    pub compliance_assessment: String,
    pub remediation_roadmap: Vec<String>,
    pub trending_analysis: String,
    pub recommendations: Vec<String>,
    pub appendices: String, // JSON with detailed technical data
}

#[napi(object)]
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct VulnerabilityBreakdown {
    pub by_severity: String, // JSON count by severity
    pub by_category: String, // JSON count by vulnerability category  
    pub by_service: String, // JSON count by affected service
    pub by_host: String, // JSON count by affected host
    pub trend_data: String, // JSON historical trend data
}

impl VulnerabilityScanningEngine {
    pub fn new() -> Self {
        let mut engine = Self {
            scan_configurations: Arc::new(DashMap::new()),
            scan_results: Arc::new(DashMap::new()),
            vulnerabilities: Arc::new(DashMap::new()),
            scan_profiles: Arc::new(DashMap::new()),
            processed_scans: Arc::new(RwLock::new(0)),
            critical_vulnerabilities: Arc::new(RwLock::new(0)),
            last_error: Arc::new(RwLock::new(None)),
        };

        engine.initialize_scan_profiles();
        engine
    }

    fn initialize_scan_profiles(&self) {
        let profiles = vec![
            ScanProfile {
                profile_id: "profile-basic".to_string(),
                name: "Basic Network Scan".to_string(),
                description: "Quick network discovery and basic vulnerability assessment".to_string(),
                scan_techniques: vec!["port_scan".to_string(), "service_detection".to_string()],
                vulnerability_checks: vec!["common_vulnerabilities".to_string(), "misconfigurations".to_string()],
                performance_settings: r#"{"timing_template": "normal", "max_threads": 10}"#.to_string(),
                evasion_techniques: vec![],
                output_formats: vec!["json".to_string()],
                created_by: "system".to_string(),
                created_time: (Utc::now() - chrono::Duration::days(30)).timestamp(),
            },
            ScanProfile {
                profile_id: "profile-comprehensive".to_string(),
                name: "Comprehensive Security Scan".to_string(),
                description: "Complete vulnerability assessment with detailed analysis".to_string(),
                scan_techniques: vec![
                    "port_scan".to_string(), 
                    "service_detection".to_string(), 
                    "version_detection".to_string(),
                    "script_scan".to_string()
                ],
                vulnerability_checks: vec![
                    "cve_database".to_string(),
                    "web_applications".to_string(),
                    "ssl_tls".to_string(),
                    "authentication".to_string(),
                    "configuration".to_string()
                ],
                performance_settings: r#"{"timing_template": "aggressive", "max_threads": 20}"#.to_string(),
                evasion_techniques: vec!["timing_randomization".to_string()],
                output_formats: vec!["json".to_string(), "xml".to_string(), "pdf".to_string()],
                created_by: "security_team".to_string(),
                created_time: (Utc::now() - chrono::Duration::days(15)).timestamp(),
            },
            ScanProfile {
                profile_id: "profile-compliance".to_string(),
                name: "Compliance Assessment".to_string(),
                description: "Focused scan for compliance requirements (PCI, HIPAA, etc.)".to_string(),
                scan_techniques: vec!["service_detection".to_string(), "version_detection".to_string()],
                vulnerability_checks: vec![
                    "compliance_checks".to_string(),
                    "encryption_standards".to_string(),
                    "access_controls".to_string(),
                    "audit_logging".to_string()
                ],
                performance_settings: r#"{"timing_template": "polite", "max_threads": 5}"#.to_string(),
                evasion_techniques: vec![],
                output_formats: vec!["json".to_string(), "pdf".to_string(), "csv".to_string()],
                created_by: "compliance_team".to_string(),
                created_time: (Utc::now() - chrono::Duration::days(20)).timestamp(),
            },
        ];

        for profile in profiles {
            self.scan_profiles.insert(profile.profile_id.clone(), profile);
        }
    }

    pub async fn get_scan_history(&self, days: i64) -> Vec<VulnerabilityScanResult> {
        let threshold = (Utc::now() - chrono::Duration::days(days)).timestamp();
        self.scan_results
            .iter()
            .filter(|entry| entry.value().start_time > threshold)
            .map(|entry| entry.value().clone())
            .collect()
    }

    pub async fn get_vulnerabilities_by_severity(&self, severity: &str) -> Vec<VulnerabilityData> {
        self.vulnerabilities
            .iter()
            .filter(|entry| entry.value().severity == severity)
            .map(|entry| entry.value().clone())
            .collect()
    }

    pub async fn get_vulnerability_statistics(&self) -> HashMap<String, u32> {
        let mut stats = HashMap::new();
        
        for entry in self.vulnerabilities.iter() {
            let vuln = entry.value();
            let count = stats.entry(vuln.severity.clone()).or_insert(0);
            *count += 1;
        }

        stats
    }

    fn simulate_vulnerability_discovery(&self, scan_config: &VulnerabilityScanConfig, scan_id: &str) -> Vec<VulnerabilityData> {
        let mut vulnerabilities = vec![];

        // Simulate different vulnerabilities based on scan type
        match scan_config.scan_type.as_str() {
            "web_application" => {
                vulnerabilities.push(VulnerabilityData {
                    vulnerability_id: format!("vuln-web-{}", Utc::now().timestamp()),
                    cve_id: Some("CVE-2023-12345".to_string()),
                    title: "SQL Injection in Login Form".to_string(),
                    description: "The login form is vulnerable to SQL injection attacks through the username parameter".to_string(),
                    severity: "high".to_string(),
                    cvss_score: 8.1,
                    cvss_vector: Some("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N".to_string()),
                    category: "injection".to_string(),
                    affected_component: "login.php".to_string(),
                    service: "HTTP".to_string(),
                    port: 80,
                    protocol: "TCP".to_string(),
                    discovery_method: "automated_testing".to_string(),
                    proof_of_concept: Some("username=' OR 1=1 --&password=test".to_string()),
                    references: vec!["https://owasp.org/www-project-top-ten/".to_string()],
                    first_detected: Utc::now().timestamp(),
                    last_verified: Utc::now().timestamp(),
                    scan_id: scan_id.to_string(),
                    target: scan_config.target_specification.clone(),
                });

                vulnerabilities.push(VulnerabilityData {
                    vulnerability_id: format!("vuln-xss-{}", Utc::now().timestamp()),
                    cve_id: None,
                    title: "Cross-Site Scripting (XSS) in Search Function".to_string(),
                    description: "Reflected XSS vulnerability in search parameter allows script injection".to_string(),
                    severity: "medium".to_string(),
                    cvss_score: 6.1,
                    cvss_vector: Some("CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N".to_string()),
                    category: "xss".to_string(),
                    affected_component: "search.php".to_string(),
                    service: "HTTP".to_string(),
                    port: 80,
                    protocol: "TCP".to_string(),
                    discovery_method: "automated_testing".to_string(),
                    proof_of_concept: Some("search=<script>alert('XSS')</script>".to_string()),
                    references: vec!["https://owasp.org/www-community/attacks/xss/".to_string()],
                    first_detected: Utc::now().timestamp(),
                    last_verified: Utc::now().timestamp(),
                    scan_id: scan_id.to_string(),
                    target: scan_config.target_specification.clone(),
                });
            },
            "network" => {
                vulnerabilities.push(VulnerabilityData {
                    vulnerability_id: format!("vuln-ssh-{}", Utc::now().timestamp()),
                    cve_id: Some("CVE-2023-67890".to_string()),
                    title: "Weak SSH Configuration".to_string(),
                    description: "SSH server allows weak encryption algorithms and password authentication".to_string(),
                    severity: "medium".to_string(),
                    cvss_score: 5.3,
                    cvss_vector: Some("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N".to_string()),
                    category: "misconfiguration".to_string(),
                    affected_component: "sshd_config".to_string(),
                    service: "SSH".to_string(),
                    port: 22,
                    protocol: "TCP".to_string(),
                    discovery_method: "service_detection".to_string(),
                    proof_of_concept: None,
                    references: vec!["https://www.ssh.com/academy/ssh/sshd_config".to_string()],
                    first_detected: Utc::now().timestamp(),
                    last_verified: Utc::now().timestamp(),
                    scan_id: scan_id.to_string(),
                    target: scan_config.target_specification.clone(),
                });

                vulnerabilities.push(VulnerabilityData {
                    vulnerability_id: format!("vuln-ssl-{}", Utc::now().timestamp()),
                    cve_id: None,
                    title: "Weak SSL/TLS Configuration".to_string(),
                    description: "Server supports deprecated SSL/TLS versions and weak cipher suites".to_string(),
                    severity: "low".to_string(),
                    cvss_score: 3.7,
                    cvss_vector: Some("CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N".to_string()),
                    category: "weak_crypto".to_string(),
                    affected_component: "SSL/TLS Configuration".to_string(),
                    service: "HTTPS".to_string(),
                    port: 443,
                    protocol: "TCP".to_string(),
                    discovery_method: "ssl_scan".to_string(),
                    proof_of_concept: None,
                    references: vec!["https://wiki.mozilla.org/Security/Server_Side_TLS".to_string()],
                    first_detected: Utc::now().timestamp(),
                    last_verified: Utc::now().timestamp(),
                    scan_id: scan_id.to_string(),
                    target: scan_config.target_specification.clone(),
                });
            },
            "database" => {
                vulnerabilities.push(VulnerabilityData {
                    vulnerability_id: format!("vuln-db-{}", Utc::now().timestamp()),
                    cve_id: Some("CVE-2023-11111".to_string()),
                    title: "Database Default Credentials".to_string(),
                    description: "Database server is using default administrative credentials".to_string(),
                    severity: "critical".to_string(),
                    cvss_score: 9.8,
                    cvss_vector: Some("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H".to_string()),
                    category: "default_credentials".to_string(),
                    affected_component: "MySQL Server".to_string(),
                    service: "MySQL".to_string(),
                    port: 3306,
                    protocol: "TCP".to_string(),
                    discovery_method: "credential_testing".to_string(),
                    proof_of_concept: Some("Username: admin, Password: admin".to_string()),
                    references: vec!["https://dev.mysql.com/doc/refman/8.0/en/default-privileges.html".to_string()],
                    first_detected: Utc::now().timestamp(),
                    last_verified: Utc::now().timestamp(),
                    scan_id: scan_id.to_string(),
                    target: scan_config.target_specification.clone(),
                });
            },
            _ => {
                // Default case - add some generic vulnerabilities
                vulnerabilities.push(VulnerabilityData {
                    vulnerability_id: format!("vuln-info-{}", Utc::now().timestamp()),
                    cve_id: None,
                    title: "Information Disclosure".to_string(),
                    description: "Server banner reveals version information".to_string(),
                    severity: "info".to_string(),
                    cvss_score: 0.0,
                    cvss_vector: None,
                    category: "information_disclosure".to_string(),
                    affected_component: "Server Header".to_string(),
                    service: "HTTP".to_string(),
                    port: 80,
                    protocol: "TCP".to_string(),
                    discovery_method: "banner_grabbing".to_string(),
                    proof_of_concept: None,
                    references: vec![],
                    first_detected: Utc::now().timestamp(),
                    last_verified: Utc::now().timestamp(),
                    scan_id: scan_id.to_string(),
                    target: scan_config.target_specification.clone(),
                });
            }
        }

        vulnerabilities
    }
}

#[async_trait]
impl VulnerabilityScanningTrait for VulnerabilityScanningEngine {
    async fn start_scan(&self, scan_config: VulnerabilityScanConfig) -> VulnerabilityScanResult {
        let mut processed_scans = self.processed_scans.write().await;
        *processed_scans += 1;

        let scan_id = scan_config.scan_id.clone();
        let start_time = Utc::now().timestamp();

        // Store scan configuration
        self.scan_configurations.insert(scan_id.clone(), scan_config.clone());

        // Simulate scanning process
        let discovered_vulnerabilities = self.simulate_vulnerability_discovery(&scan_config, &scan_id);

        // Count vulnerabilities by severity
        let mut critical_count = 0;
        let mut high_count = 0;
        let mut medium_count = 0;
        let mut low_count = 0;
        let mut info_count = 0;

        for vuln in &discovered_vulnerabilities {
            match vuln.severity.as_str() {
                "critical" => critical_count += 1,
                "high" => high_count += 1,
                "medium" => medium_count += 1,
                "low" => low_count += 1,
                "info" => info_count += 1,
                _ => {}
            }

            // Store vulnerability
            self.vulnerabilities.insert(vuln.vulnerability_id.clone(), vuln.clone());
        }

        // Update critical vulnerabilities counter
        let mut critical_vulnerabilities = self.critical_vulnerabilities.write().await;
        *critical_vulnerabilities += critical_count;

        // Calculate scan metrics
        let targets_scanned = scan_config.target_specification.split(',').count() as u32;
        let hosts_discovered = targets_scanned; // Assume all targets respond
        let services_identified = discovered_vulnerabilities.len() as u32 * 2; // Estimate 2 services per vulnerability
        
        // Simulate scan duration based on depth
        let scan_duration = match scan_config.scan_depth.as_str() {
            "basic" => 300,     // 5 minutes
            "standard" => 1800, // 30 minutes
            "comprehensive" => 7200, // 2 hours
            "intrusive" => 14400,    // 4 hours
            _ => 600,
        };

        let scan_coverage = match scan_config.scan_depth.as_str() {
            "basic" => 60.0,
            "standard" => 80.0,
            "comprehensive" => 95.0,
            "intrusive" => 98.0,
            _ => 70.0,
        };

        let compliance_status = if !scan_config.compliance_frameworks.is_empty() {
            let mut compliance_results = HashMap::new();
            for framework in &scan_config.compliance_frameworks {
                let compliance_score = match critical_count + high_count {
                    0 => 95,
                    1..=2 => 80,
                    3..=5 => 60,
                    _ => 40,
                };
                compliance_results.insert(framework, compliance_score);
            }
            serde_json::to_string(&compliance_results).unwrap_or_default()
        } else {
            "{}".to_string()
        };

        let top_vulnerabilities: Vec<String> = discovered_vulnerabilities
            .iter()
            .filter_map(|v| v.cve_id.clone())
            .take(5)
            .collect();

        let end_time = start_time + scan_duration;
        let result = VulnerabilityScanResult {
            scan_id: scan_id.clone(),
            scan_name: scan_config.name,
            status: "completed".to_string(),
            start_time,
            end_time: Some(end_time),
            targets_scanned,
            hosts_discovered,
            services_identified,
            vulnerabilities_found: discovered_vulnerabilities.len() as u32,
            critical_count,
            high_count,
            medium_count,
            low_count,
            info_count,
            scan_duration,
            scan_coverage,
            compliance_status,
            top_vulnerabilities,
        };

        // Store scan result
        self.scan_results.insert(scan_id, result.clone());

        result
    }

    async fn assess_vulnerability(&self, vuln_data: VulnerabilityData) -> VulnerabilityAssessment {
        let assessment_id = format!("assess-{}", Utc::now().timestamp());

        // Calculate risk score based on CVSS and exploitability
        let base_risk = vuln_data.cvss_score;
        let exploitability_modifier = match vuln_data.category.as_str() {
            "injection" | "default_credentials" => 1.2,
            "xss" | "misconfiguration" => 1.0,
            "information_disclosure" => 0.8,
            _ => 1.0,
        };
        let risk_score = (base_risk * exploitability_modifier).min(10.0);

        // Determine business impact and priority
        let (business_impact, remediation_priority, remediation_effort) = match vuln_data.severity.as_str() {
            "critical" => ("critical", "immediate", "minimal"),
            "high" => ("high", "high", "moderate"),
            "medium" => ("medium", "medium", "moderate"),
            "low" => ("low", "low", "significant"),
            _ => ("low", "low", "minimal"),
        };

        let exploitability = match vuln_data.proof_of_concept {
            Some(_) => "functional",
            None => match vuln_data.cvss_score {
                score if score >= 7.0 => "high",
                score if score >= 4.0 => "proof_of_concept",
                _ => "not_defined",
            },
        };

        let impact_analysis = format!(
            "CVSS Score: {:.1}, Category: {}, Affected Service: {} on port {}",
            vuln_data.cvss_score, vuln_data.category, vuln_data.service, vuln_data.port
        );

        let remediation_recommendations = match vuln_data.category.as_str() {
            "injection" => vec![
                "Implement parameterized queries".to_string(),
                "Apply input validation and sanitization".to_string(),
                "Use least privilege database accounts".to_string(),
            ],
            "xss" => vec![
                "Implement output encoding".to_string(),
                "Use Content Security Policy (CSP)".to_string(),
                "Validate and sanitize user input".to_string(),
            ],
            "default_credentials" => vec![
                "Change default credentials immediately".to_string(),
                "Implement strong password policy".to_string(),
                "Enable multi-factor authentication".to_string(),
            ],
            "misconfiguration" => vec![
                "Review and harden configuration".to_string(),
                "Disable unnecessary services".to_string(),
                "Apply security patches".to_string(),
            ],
            _ => vec![
                "Review vendor security advisories".to_string(),
                "Apply latest security patches".to_string(),
                "Monitor for exploitation attempts".to_string(),
            ],
        };

        let compensating_controls = match vuln_data.severity.as_str() {
            "critical" | "high" => vec![
                "Implement network segmentation".to_string(),
                "Deploy intrusion detection".to_string(),
                "Increase monitoring and logging".to_string(),
            ],
            _ => vec![
                "Monitor for unusual activity".to_string(),
                "Regular vulnerability reassessment".to_string(),
            ],
        };

        let false_positive_likelihood = match vuln_data.discovery_method.as_str() {
            "automated_testing" => 0.1,
            "manual_verification" => 0.05,
            "banner_grabbing" => 0.3,
            _ => 0.2,
        };

        VulnerabilityAssessment {
            assessment_id,
            vulnerability_id: vuln_data.vulnerability_id,
            risk_score,
            exploitability: exploitability.to_string(),
            impact_analysis,
            affected_assets: vec![vuln_data.target],
            business_impact: business_impact.to_string(),
            remediation_priority: remediation_priority.to_string(),
            remediation_effort: remediation_effort.to_string(),
            remediation_recommendations,
            compensating_controls,
            false_positive_likelihood,
            assessment_date: Utc::now().timestamp(),
            assessed_by: "automated_assessment_engine".to_string(),
        }
    }

    async fn generate_report(&self, scan_id: &str) -> Option<VulnerabilityReport> {
        let scan_result = self.scan_results.get(scan_id)?;
        let scan_result = scan_result.clone();

        let report_id = format!("report-{}-{}", scan_id, Utc::now().timestamp());
        
        // Get vulnerabilities for this scan
        let scan_vulnerabilities: Vec<VulnerabilityData> = self.vulnerabilities
            .iter()
            .filter(|entry| entry.value().scan_id == scan_id)
            .map(|entry| entry.value().clone())
            .collect();

        // Create vulnerability breakdown
        let by_severity = format!(r#"{{"critical": {}, "high": {}, "medium": {}, "low": {}, "info": {}}}"#,
            scan_result.critical_count, scan_result.high_count, scan_result.medium_count,
            scan_result.low_count, scan_result.info_count);

        let mut by_category = HashMap::new();
        let mut by_service = HashMap::new();
        let mut by_host = HashMap::new();

        for vuln in &scan_vulnerabilities {
            *by_category.entry(vuln.category.clone()).or_insert(0) += 1;
            *by_service.entry(vuln.service.clone()).or_insert(0) += 1;
            *by_host.entry(vuln.target.clone()).or_insert(0) += 1;
        }

        let vulnerability_breakdown = VulnerabilityBreakdown {
            by_severity,
            by_category: serde_json::to_string(&by_category).unwrap_or_default(),
            by_service: serde_json::to_string(&by_service).unwrap_or_default(),
            by_host: serde_json::to_string(&by_host).unwrap_or_default(),
            trend_data: "{}".to_string(), // Would contain historical data
        };

        // Generate executive summary
        let executive_summary = format!(
            "Vulnerability scan completed on {} target(s) discovering {} vulnerabilities. {} critical and {} high-severity issues require immediate attention. Overall security posture shows {:.1}% scan coverage with {} services identified.",
            scan_result.targets_scanned,
            scan_result.vulnerabilities_found,
            scan_result.critical_count,
            scan_result.high_count,
            scan_result.scan_coverage,
            scan_result.services_identified
        );

        let risk_analysis = format!(
            "Risk assessment indicates {} immediate threats requiring urgent remediation. Medium-risk vulnerabilities ({} findings) should be addressed within 30 days.",
            scan_result.critical_count + scan_result.high_count,
            scan_result.medium_count
        );

        let compliance_assessment = if !scan_result.compliance_status.is_empty() && scan_result.compliance_status != "{}" {
            format!("Compliance assessment completed for configured frameworks. See detailed compliance status: {}", scan_result.compliance_status)
        } else {
            "No compliance frameworks specified for this scan.".to_string()
        };

        let remediation_roadmap = vec![
            format!("Phase 1 (Immediate): Address {} critical vulnerabilities", scan_result.critical_count),
            format!("Phase 2 (30 days): Remediate {} high-severity issues", scan_result.high_count),
            format!("Phase 3 (90 days): Address {} medium-severity vulnerabilities", scan_result.medium_count),
            "Phase 4 (Ongoing): Monitor and address low/info findings".to_string(),
        ];

        let recommendations = vec![
            "Implement automated vulnerability scanning schedule".to_string(),
            "Establish vulnerability management process".to_string(),
            "Deploy compensating controls for critical assets".to_string(),
            "Provide security awareness training".to_string(),
            "Regular security configuration reviews".to_string(),
        ];

        Some(VulnerabilityReport {
            report_id,
            scan_id: scan_id.to_string(),
            report_type: "technical".to_string(),
            generation_time: Utc::now().timestamp(),
            report_period: "Point-in-time assessment".to_string(),
            executive_summary,
            scan_summary: scan_result,
            vulnerability_breakdown,
            risk_analysis,
            compliance_assessment,
            remediation_roadmap,
            trending_analysis: "Historical trending data not available for this report period.".to_string(),
            recommendations,
            appendices: serde_json::to_string(&scan_vulnerabilities).unwrap_or_default(),
        })
    }

    async fn get_status(&self) -> ComponentStatus {
        let processed_scans = *self.processed_scans.read().await;
        let critical_vulnerabilities = *self.critical_vulnerabilities.read().await;
        let last_error = self.last_error.read().await.clone();

        ComponentStatus {
            status: "operational".to_string(),
            uptime: 0,
            processed_events: processed_scans as i64,
            active_alerts: critical_vulnerabilities,
            last_error,
        }
    }
}