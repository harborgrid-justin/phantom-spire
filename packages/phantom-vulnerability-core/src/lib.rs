// phantom-vulnerability-core/src/lib.rs
// Advanced vulnerability assessment and management library

use napi::bindgen_prelude::*;
use napi_derive::napi;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityAssessment {
    pub scan_id: String,
    pub target: String,
    pub scan_type: ScanType,
    pub vulnerabilities: Vec<Vulnerability>,
    pub scan_date: DateTime<Utc>,
    pub status: ScanStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ScanType {
    Network,
    Web,
    Database,
    Infrastructure,
    Application,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ScanStatus {
    Pending,
    Running,
    Completed,
    Failed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub name: String,
    pub severity: VulnerabilitySeverity,
    pub cvss_score: Option<f64>,
    pub description: String,
    pub solution: String,
    pub references: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum VulnerabilitySeverity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

pub struct VulnerabilityCore {
    assessments: HashMap<String, VulnerabilityAssessment>,
}

impl VulnerabilityCore {
    pub fn new() -> Result<Self, String> {
        Ok(Self {
            assessments: HashMap::new(),
        })
    }

    pub fn start_scan(&mut self, target: &str, scan_type: ScanType) -> Result<String, String> {
        let scan_id = Uuid::new_v4().to_string();
        
        let assessment = VulnerabilityAssessment {
            scan_id: scan_id.clone(),
            target: target.to_string(),
            scan_type,
            vulnerabilities: vec![
                Vulnerability {
                    id: "vuln_001".to_string(),
                    name: "Outdated Software Component".to_string(),
                    severity: VulnerabilitySeverity::Medium,
                    cvss_score: Some(5.5),
                    description: "Software component is outdated and may contain vulnerabilities".to_string(),
                    solution: "Update to latest version".to_string(),
                    references: vec!["https://cve.mitre.org".to_string()],
                }
            ],
            scan_date: Utc::now(),
            status: ScanStatus::Completed,
        };

        self.assessments.insert(scan_id.clone(), assessment);
        Ok(scan_id)
    }

    pub fn get_scan_results(&self, scan_id: &str) -> Result<Option<VulnerabilityAssessment>, String> {
        Ok(self.assessments.get(scan_id).cloned())
    }
}

#[napi]
pub struct VulnerabilityCoreNapi {
    inner: VulnerabilityCore,
}

#[napi]
impl VulnerabilityCoreNapi {
    #[napi(constructor)]
    pub fn new() -> Result<Self> {
        let core = VulnerabilityCore::new()
            .map_err(|e| napi::Error::from_reason(format!("Failed to create Vulnerability Core: {}", e)))?;
        Ok(VulnerabilityCoreNapi { inner: core })
    }

    #[napi]
    pub fn start_scan(&mut self, target: String, scan_type: String) -> Result<String> {
        let scan_type_enum = match scan_type.as_str() {
            "network" => ScanType::Network,
            "web" => ScanType::Web,
            "database" => ScanType::Database,
            "infrastructure" => ScanType::Infrastructure,
            "application" => ScanType::Application,
            _ => ScanType::Network,
        };

        self.inner.start_scan(&target, scan_type_enum)
            .map_err(|e| napi::Error::from_reason(format!("Failed to start scan: {}", e)))
    }

    #[napi]
    pub fn get_health_status(&self) -> Result<String> {
        let status = serde_json::json!({
            "status": "healthy",
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "version": env!("CARGO_PKG_VERSION")
        });

        serde_json::to_string(&status)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize health status: {}", e)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vulnerability_core_creation() {
        let core = VulnerabilityCore::new();
        assert!(core.is_ok());
    }
}
