use chrono::Utc;
use std::cell::Cell;
use crate::exploit_predictor::ExploitPredictor;
use crate::models::{
    CVE, CVEAnalysisResult, CVSSAttackVector, ExploitTimeline, RemediationStrategy, SearchCriteria,
    TargetProfile, VulnerabilityAssessment,
};
use crate::remediation_engine::RemediationEngine;
use crate::threat_intelligence::ThreatIntelligenceEngine;
use crate::vulnerability_scorer::VulnerabilityScorer;

// Core processing logic with advanced threat intelligence
pub struct CVECore {
    pub(crate) threat_intel_engine: ThreatIntelligenceEngine,
    pub(crate) vulnerability_scorer: VulnerabilityScorer,
    pub(crate) exploit_predictor: ExploitPredictor,
    pub(crate) remediation_engine: RemediationEngine,
}
impl CVECore {
    pub fn new() -> Result<Self, String> {
        Ok(Self {
            threat_intel_engine: ThreatIntelligenceEngine::new(),
            vulnerability_scorer: VulnerabilityScorer::new(),
            exploit_predictor: ExploitPredictor::new(),
            remediation_engine: RemediationEngine::new(),
        })
    }
    // Extract/Introduce constants to avoid magic numbers
    const DEFAULT_BASE_SCORE: f64 = 5.0;
    const RISK_CRITICAL: f64 = 9.0;
    const RISK_HIGH: f64 = 7.0;
    const RISK_MEDIUM: f64 = 4.0;

    // Extract function: compute risk level from adjusted score
    fn compute_risk_level(adjusted_score: f64) -> &'static str {
        if adjusted_score >= Self::RISK_CRITICAL {
            "critical"
        } else if adjusted_score >= Self::RISK_HIGH {
            "high"
        } else if adjusted_score >= Self::RISK_MEDIUM {
            "medium"
        } else {
            "low"
        }
    }

    // Extract function: isolate score adjustment logic
    fn adjust_score(base_score: f64, intel_boost: f64) -> f64 {
        base_score * (1.0 + intel_boost)
    }

    // Extract function: centralize CVSS attack vector mapping
    fn attack_vector_to_str(vector: CVSSAttackVector) -> &'static str {
        match vector {
            CVSSAttackVector::Network => "network",
            CVSSAttackVector::Adjacent => "adjacent",
            CVSSAttackVector::Local => "local",
            CVSSAttackVector::Physical => "physical",
        }
    }

    pub fn process_cve(&self, cve: CVE) -> Result<CVEAnalysisResult, String> {
        // Advanced CVE processing with threat intelligence correlation
        let assessment = self.build_advanced_assessment(&cve)?;
        let related_cves = self.discover_related_vulnerabilities(&cve)?;
        let threat_actors = self.correlate_threat_actors(&cve)?;
        let campaigns = self.map_to_campaigns(&cve)?;
        Ok(CVEAnalysisResult {
            cve,
            assessment,
            processing_timestamp: Utc::now(),
            related_cves,
            threat_actors,
            campaigns,
        })
    }
    pub fn batch_process_cves(&self, cves: Vec<CVE>) -> Result<Vec<CVEAnalysisResult>, String> {
        // Streamlined, readable iterator-based processing with error logging
        let results = cves
            .into_iter()
            .filter_map(|cve| match self.process_cve(cve) {
                Ok(result) => Some(result),
                Err(e) => {
                    eprintln!("Failed to process CVE: {}", e);
                    None
                }
            })
            .collect();
        Ok(results)
    }
    pub fn search_vulnerabilities(&self, criteria: SearchCriteria) -> Result<Vec<CVE>, String> {
        // Advanced vulnerability search with intelligence correlation
        self.threat_intel_engine.search_with_criteria(criteria)
    }
    pub fn get_exploit_timeline(&self, cve_id: &str) -> Result<ExploitTimeline, String> {
        self.exploit_predictor.generate_timeline(cve_id)
    }
    pub fn get_remediation_strategy(&self, cve: &CVE) -> Result<RemediationStrategy, String> {
        self.remediation_engine.generate_strategy(cve)
    }
    // Renamed for clarity: generate_advanced_assessment -> build_advanced_assessment
    fn build_advanced_assessment(&self, cve: &CVE) -> Result<VulnerabilityAssessment, String> {
        let base_score = cve.cvss_metrics.as_ref().map(|m| m.base_score).unwrap_or(Self::DEFAULT_BASE_SCORE);
        // Advanced scoring with multiple factors
        let exploitability = self.vulnerability_scorer.calculate_exploitability(cve)?;
        let impact_score = self.vulnerability_scorer.calculate_impact(cve)?;
        let threat_intel_boost = self.threat_intel_engine.get_intelligence_boost(cve)?;
        let adjusted_score = Self::adjust_score(base_score, threat_intel_boost);
        let risk_level = Self::compute_risk_level(adjusted_score);
        let affected_systems = self.identify_affected_systems(cve)?;
        let exploit_status = self.exploit_predictor.assess_exploit_status(cve)?;
        let recommendations = self.generate_contextual_recommendations(cve)?;
        let mitigation_steps = self.remediation_engine.get_immediate_mitigations(cve)?;
        Ok(VulnerabilityAssessment {
            exploitability,
            impact_score,
            risk_level: risk_level.to_string(),
            affected_systems,
            remediation_priority: self.calculate_remediation_priority(adjusted_score, exploitability),
            exploit_available: exploit_status.exploit_available,
            public_exploits: exploit_status.public_exploits,
            in_the_wild: exploit_status.in_the_wild,
            recommendations,
            mitigation_steps,
        })
    }
    fn discover_related_vulnerabilities(&self, cve: &CVE) -> Result<Vec<String>, String> {
        let mut related = Vec::new();
        // Find vulnerabilities in same product family
        for product in &cve.affected_products {
            let product_vulns = self
                .threat_intel_engine
                .find_product_vulnerabilities(&product.vendor, &product.product)?;
            related.extend(product_vulns);
        }
        // Find vulnerabilities with similar attack vectors
        if let Some(cvss) = &cve.cvss_metrics {
            let attack_vector_str = Self::attack_vector_to_str(cvss.attack_vector);
            let similar_vulns = self
                .threat_intel_engine
                .find_similar_attack_patterns(attack_vector_str)?;
            related.extend(similar_vulns);
        }
        // Find vulnerabilities exploited by same threat actors
        let actor_vulns = self
            .threat_intel_engine
            .find_actor_preferred_vulnerabilities(&cve.id)?;
        related.extend(actor_vulns);
        Ok(related.into_iter().take(10).collect())
    }
    fn correlate_threat_actors(&self, cve: &CVE) -> Result<Vec<String>, String> {
        let mut actors = Vec::new();
        // Advanced threat actor correlation based on:
        // 1. Exploit availability and timeline
        // 2. Target profile matching
        // 3. Attack technique similarity
        // 4. Historical exploitation patterns
        let exploit_timeline = self.exploit_predictor.get_basic_timeline(&cve.id)?;
        let target_profile = self.analyze_target_profile(cve)?;
        if exploit_timeline.has_public_exploits {
            actors.extend(self.threat_intel_engine.get_opportunistic_actors()?);
        }
        if target_profile.high_value_targets {
            actors.extend(self.threat_intel_engine.get_apt_actors()?);
        }
        if let Some(cvss) = &cve.cvss_metrics {
            if cvss.base_score >= 7.0 {
                actors.extend(self.threat_intel_engine.get_sophisticated_actors()?);
            }
        }
        Ok(actors.into_iter().take(5).collect())
    }
    fn map_to_campaigns(&self, cve: &CVE) -> Result<Vec<String>, String> {
        let mut campaigns = Vec::new();
        // Map vulnerabilities to known threat campaigns
        let vulnerability_type = self.classify_vulnerability_type(cve)?;
        campaigns.extend(
            self.threat_intel_engine
                .get_campaigns_by_vuln_type(&vulnerability_type)?,
        );
        // Check for zero-day usage in campaigns
        if self.exploit_predictor.is_likely_zero_day(&cve.id)? {
            campaigns.extend(self.threat_intel_engine.get_zero_day_campaigns()?);
        }
        // Check for supply chain implications
        if self.is_supply_chain_vulnerability(cve)? {
            campaigns.extend(self.threat_intel_engine.get_supply_chain_campaigns()?);
        }
        Ok(campaigns.into_iter().take(3).collect())
    }
    fn calculate_remediation_priority(&self, score: f64, exploitability: f64) -> u32 {
        let base_priority = (score * 10.0) as u32;
        let exploit_factor = (exploitability * 50.0) as u32;
        // Safer arithmetic with clamping
        base_priority
            .saturating_add(exploit_factor)
            .min(100)
    }


    fn identify_affected_systems(&self, cve: &CVE) -> Result<Vec<String>, String> {
        let mut systems = Vec::new();

        for product in &cve.affected_products {
            match product.product.to_lowercase().as_str() {
                s if s.contains("windows") => systems.push("Windows Servers".to_string()),
                s if s.contains("linux") => systems.push("Linux Servers".to_string()),
                s if s.contains("apache") => systems.push("Web Servers".to_string()),
                s if s.contains("mysql") || s.contains("postgresql") => systems.push("Database Servers".to_string()),
                s if s.contains("exchange") => systems.push("Email Servers".to_string()),
                s if s.contains("cisco") => systems.push("Network Infrastructure".to_string()),
                _ => systems.push("Application Servers".to_string()),
            }
        }

        if systems.is_empty() {
            systems.push("General Systems".to_string());
        }

        Ok(systems)
    }

    fn generate_contextual_recommendations(&self, cve: &CVE) -> Result<Vec<String>, String> {
        let mut recommendations = Vec::new();

        let base_score = cve.cvss_metrics.as_ref().map(|m| m.base_score).unwrap_or(5.0);

        if base_score >= 9.0 {
            recommendations.push("CRITICAL: Apply emergency patches immediately".to_string());
            recommendations.push("Implement temporary workarounds if patches unavailable".to_string());
            recommendations.push("Consider system isolation until patched".to_string());
        } else if base_score >= 7.0 {
            recommendations.push("Apply vendor patches within 24-48 hours".to_string());
            recommendations.push("Increase monitoring for exploitation attempts".to_string());
        } else {
            recommendations.push("Apply patches during next maintenance window".to_string());
            recommendations.push("Review and update security configurations".to_string());
        }

        recommendations.push("Implement defense-in-depth measures".to_string());
        recommendations.push("Update threat hunting signatures".to_string());
        recommendations.push("Brief security team on new threat vectors".to_string());

        Ok(recommendations)
    }

    fn analyze_target_profile(&self, cve: &CVE) -> Result<TargetProfile, String> {
        let mut high_value = false;
        let mut widespread = false;

        for product in &cve.affected_products {
            match product.product.to_lowercase().as_str() {
                s if s.contains("windows") || s.contains("office") => {
                    widespread = true;
                    high_value = true;
                }
                s if s.contains("exchange") || s.contains("sharepoint") => {
                    high_value = true;
                }
                s if s.contains("apache") || s.contains("nginx") => {
                    widespread = true;
                }
                _ => {}
            }
        }

        Ok(TargetProfile { high_value_targets: high_value, widespread_deployment: widespread })
    }

    fn classify_vulnerability_type(&self, cve: &CVE) -> Result<String, String> {
        let desc = cve.description.to_lowercase();

        if desc.contains("remote code execution") || desc.contains("rce") {
            Ok("remote_code_execution".to_string())
        } else if desc.contains("privilege escalation") {
            Ok("privilege_escalation".to_string())
        } else if desc.contains("denial of service") || desc.contains("dos") {
            Ok("denial_of_service".to_string())
        } else if desc.contains("information disclosure") {
            Ok("information_disclosure".to_string())
        } else if desc.contains("sql injection") {
            Ok("injection".to_string())
        } else if desc.contains("cross-site scripting") || desc.contains("xss") {
            Ok("xss".to_string())
        } else {
            Ok("other".to_string())
        }
    }

    fn is_supply_chain_vulnerability(&self, cve: &CVE) -> Result<bool, String> {
        for product in &cve.affected_products {
            let product_lower = product.product.to_lowercase();
            if product_lower.contains("library")
                || product_lower.contains("framework")
                || product_lower.contains("sdk")
                || product_lower.contains("component")
            {
                return Ok(true);
            }
        }
        Ok(false)
    }

    #[allow(dead_code)]
    fn random(&self) -> u32 {
        // Simple random number generator
        static mut SEED: u64 = 12345;
        unsafe {
            SEED = SEED.wrapping_mul(1103515245).wrapping_add(12345);
            (SEED % u32::MAX as u64) as u32
        }
    }
}

pub use CVECore as Core;