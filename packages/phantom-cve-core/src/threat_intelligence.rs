use chrono::Utc;
use std::collections::HashMap;
use crate::models::{
    AffectedProduct, CVSSAttackVector, CVSSMetrics, CVSSSeverity, CVSSVersion, CorrelationRule, Reference,
    SearchCriteria, ThreatFeed, CVE,
};

// Introduced constants to replace magic numbers and hard-coded lists
const FEED_HIT_WEIGHT: f64 = 0.1;
const ACTIVE_EXPLOIT_WEIGHT: f64 = 0.3;
const ACTOR_INTEREST_WEIGHT: f64 = 0.2;

const ACTORS_OPPORTUNISTIC: &[&str] = &[
    "Script Kiddies",
    "Cyber Criminal Groups",
    "Hacktivists",
];

const ACTORS_APT: &[&str] = &[
    "APT29",
    "APT41",
    "Lazarus Group",
    "Sandworm",
];

const ACTORS_SOPHISTICATED: &[&str] = &[
    "APT28",
    "APT29",
    "Equation Group",
    "FIN7",
];

#[allow(dead_code)]
pub struct ThreatIntelligenceEngine {
    pub(crate) feeds: HashMap<String, ThreatFeed>,
    pub(crate) correlation_rules: Vec<CorrelationRule>,
}
impl ThreatIntelligenceEngine {
    pub fn new() -> Self {
        // Extracted: centralized, deduplicated feed initialization
        let feeds = Self::init_default_feeds();
        Self { feeds, correlation_rules: Vec::new() }
    }

    // Helper to initialize default feeds with a single timestamp and compact mapping
    fn init_default_feeds() -> HashMap<String, ThreatFeed> {
        let now = Utc::now();
        let definitions = [
            ("alienvault_otx", "AlienVault OTX", 0.9, "open_source"),
            ("abuseipdb", "AbuseIPDB", 0.8, "reputation"),
            ("threatstream", "Anomali ThreatStream", 0.95, "commercial"),
        ];
        let mut feeds = HashMap::new();
        for (id, name, reliability, feed_type) in definitions {
            feeds.insert(
                id.to_string(),
                ThreatFeed {
                    id: id.to_string(),
                    name: name.to_string(),
                    reliability,
                    last_updated: now,
                    feed_type: feed_type.to_string(),
                },
            );
        }
        feeds
    }

    pub fn get_intelligence_boost(&self, cve: &CVE) -> Result<f64, String> {
        // Replaced loop + mutation with iterator sum and named weights for clarity
        let feed_boost: f64 = self.feeds.values()
            .map(|feed| -> Result<f64, String> {
                Ok(if self.is_cve_in_feed(cve, feed)? { feed.reliability * FEED_HIT_WEIGHT } else { 0.0 })
            })
            .try_fold(0.0, |acc, v| v.map(|b| acc + b))?;

        let active_exploit_boost = if self.is_cve_being_exploited(cve)? { ACTIVE_EXPLOIT_WEIGHT } else { 0.0 };
        let actor_interest_boost = if self.is_cve_targeted_by_actors(cve)? { ACTOR_INTEREST_WEIGHT } else { 0.0 };

        Ok((feed_boost + active_exploit_boost + actor_interest_boost).min(1.0))
    }

    pub fn find_product_vulnerabilities(&self, _vendor: &str, _product: &str) -> Result<Vec<String>, String> {
        // DRY: use helper to generate mock CVE ids
        Ok(self.generate_mock_cve_ids(5, 10_000, 2024))
    }

    pub fn find_similar_attack_patterns(&self, _attack_vector: &str) -> Result<Vec<String>, String> {
        // DRY: use helper to generate mock CVE ids
        Ok(self.generate_mock_cve_ids(3, 20_000, 2024))
    }

    pub fn find_actor_preferred_vulnerabilities(&self, _cve_id: &str) -> Result<Vec<String>, String> {
        // DRY: use helper to generate mock CVE ids
        Ok(self.generate_mock_cve_ids(4, 30_000, 2024))
    }

    // Helper: centralizes mock CVE ID generation logic used by multiple methods
    fn generate_mock_cve_ids(&self, max_count: u32, base_number: u32, year: i32) -> Vec<String> {
        let count = (self.random() % max_count) as usize;
        (0..count)
            .map(|i| format!("CVE-{}-{:04}", year, base_number + i as u32))
            .collect()
    }

    pub fn get_opportunistic_actors(&self) -> Result<Vec<String>, String> {
        Ok(ACTORS_OPPORTUNISTIC.iter().map(|s| (*s).to_string()).collect())
    }

    pub fn get_apt_actors(&self) -> Result<Vec<String>, String> {
        Ok(ACTORS_APT.iter().map(|s| (*s).to_string()).collect())
    }

    pub fn get_sophisticated_actors(&self) -> Result<Vec<String>, String> {
        Ok(ACTORS_SOPHISTICATED.iter().map(|s| (*s).to_string()).collect())
    }

    pub fn get_campaigns_by_vuln_type(&self, vuln_type: &str) -> Result<Vec<String>, String> {
        let campaigns = match vuln_type {
            "remote_code_execution" => vec![
                "Operation Aurora".to_string(),
                "WannaCry Campaign".to_string(),
                "NotPetya Attack".to_string(),
            ],
            "privilege_escalation" => vec![
                "Dirty COW Exploitation".to_string(),
                "Local Privilege Escalation Campaigns".to_string(),
            ],
            "injection" => vec![
                "SQL Injection Campaigns".to_string(),
                "Web Application Attacks".to_string(),
            ],
            _ => vec!["Generic Exploitation".to_string()],
        };
        Ok(campaigns)
    }

    pub fn get_zero_day_campaigns(&self) -> Result<Vec<String>, String> {
        Ok(vec![
            "Zero-Day Exploitation Campaign".to_string(),
            "Advanced Persistent Threats".to_string(),
        ])
    }

    pub fn get_supply_chain_campaigns(&self) -> Result<Vec<String>, String> {
        Ok(vec![
            "SolarWinds Supply Chain Attack".to_string(),
            "Log4Shell Exploitation".to_string(),
            "Kaseya VSA Attack".to_string(),
        ])
    }

    pub fn search_with_criteria(&self, criteria: SearchCriteria) -> Result<Vec<CVE>, String> {
        // Mock implementation for advanced search
        let mut results = Vec::new();
        let count = 10 + (self.random() % 20) as usize;
        for i in 0..count {
            let year = 2024;
            let number = 40000 + i as u32;
            let cve_id = format!("CVE-{}-{:04}", year, number);
            let cve = CVE {
                id: cve_id.clone(),
                description: format!("Mock vulnerability {} for testing", i),
                published_date: Utc::now(),
                last_modified_date: Utc::now(),
                cvss_metrics: Some(CVSSMetrics {
                    version: CVSSVersion::V31,
                    base_score: 5.0 + (self.random() as f64 / u32::MAX as f64) * 5.0,
                    severity: CVSSSeverity::High,
                    attack_vector: CVSSAttackVector::Network,
                    attack_complexity: "Low".to_string(),
                    privileges_required: "None".to_string(),
                    user_interaction: "None".to_string(),
                    scope: "Unchanged".to_string(),
                    confidentiality_impact: "High".to_string(),
                    integrity_impact: "High".to_string(),
                    availability_impact: "High".to_string(),
                    exploitability_score: Some(8.0),
                    impact_score: Some(6.0),
                }),
                cwe: Some(crate::models::CWE {
                    id: "CWE-79".to_string(),
                    name: "Cross-site Scripting".to_string(),
                    description: "Improper neutralization of input during web page generation".to_string(),
                }),
                affected_products: vec![AffectedProduct {
                    vendor: criteria.vendor.clone().unwrap_or("Mock Vendor".to_string()),
                    product: criteria.product.clone().unwrap_or("Mock Product".to_string()),
                    version: "1.0.0".to_string(),
                    version_start_including: None,
                    version_end_including: None,
                    version_start_excluding: None,
                    version_end_excluding: None,
                }],
                references: vec![Reference {
                    url: format!("https://cve.mitre.org/cgi-bin/cvename.cgi?name={}", cve_id),
                    source: "MITRE".to_string(),
                    tags: vec!["vendor-advisory".to_string()],
                }],
                status: "published".to_string(),
                assigner: "cve@mitre.org".to_string(),
                tags: vec!["web-application".to_string(), "xss".to_string()],
            };

            // Apply search criteria
            if let Some(min_score) = criteria.severity_min {
                if let Some(metrics) = &cve.cvss_metrics {
                    if metrics.base_score < min_score {
                        continue;
                    }
                }
            }

            if let Some(max_score) = criteria.severity_max {
                if let Some(metrics) = &cve.cvss_metrics {
                    if metrics.base_score > max_score {
                        continue;
                    }
                }
            }

            results.push(cve);
        }

        Ok(results)
    }

    fn is_cve_in_feed(&self, _cve: &CVE, _feed: &ThreatFeed) -> Result<bool, String> {
        // Mock implementation
        Ok(self.random() % 10 < 3) // 30% chance
    }

    fn is_cve_being_exploited(&self, _cve: &CVE) -> Result<bool, String> {
        // Mock implementation
        Ok(self.random() % 10 < 2) // 20% chance
    }

    fn is_cve_targeted_by_actors(&self, _cve: &CVE) -> Result<bool, String> {
        // Mock implementation
        Ok(self.random() % 10 < 4) // 40% chance
    }

    fn random(&self) -> u32 {
        static mut SEED: u64 = 98765;
        unsafe {
            SEED = SEED.wrapping_mul(1103515245).wrapping_add(12345);
            (SEED % u32::MAX as u64) as u32
        }
    }
}

// Re-export for external modules
pub use ThreatIntelligenceEngine as TIEngine;
