use chrono::Utc;

use crate::models::{CVE, CVSSAttackVector};

#[allow(dead_code)]
pub struct VulnerabilityScorer {
    pub(crate) scoring_models: Vec<crate::models::ScoringModel>,
}

impl VulnerabilityScorer {
    pub fn new() -> Self {
        Self {
            scoring_models: vec![
                crate::models::ScoringModel {
                    name: "temporal_scoring".to_string(),
                    weight: 0.3,
                    factors: vec!["age".to_string(), "patch_availability".to_string()],
                },
                crate::models::ScoringModel {
                    name: "environmental_scoring".to_string(),
                    weight: 0.4,
                    factors: vec!["asset_value".to_string(), "exposure".to_string()],
                },
                crate::models::ScoringModel {
                    name: "threat_scoring".to_string(),
                    weight: 0.3,
                    factors: vec!["actor_interest".to_string(), "exploit_maturity".to_string()],
                },
            ],
        }
    }

    pub fn calculate_exploitability(&self, cve: &CVE) -> Result<f64, String> {
        let mut score = 0.0;

        // Base exploitability from CVSS
        if let Some(cvss) = &cve.cvss_metrics {
            score += cvss.base_score * 0.4;

            // Attack vector bonus
            match cvss.attack_vector {
                CVSSAttackVector::Network => score += 0.3,
                CVSSAttackVector::Adjacent => score += 0.2,
                CVSSAttackVector::Local => score += 0.1,
                CVSSAttackVector::Physical => score += 0.05,
            }

            // Complexity penalty
            if cvss.attack_complexity == "High" {
                score *= 0.8;
            }

            // Privileges bonus
            if cvss.privileges_required == "None" {
                score += 0.2;
            }

            // User interaction penalty
            if cvss.user_interaction == "Required" {
                score *= 0.7;
            }
        }

        // Age factor (newer vulnerabilities are more likely to be exploited)
        let age_days = (Utc::now() - cve.published_date).num_days();
        if age_days < 30 {
            score += 0.1;
        } else if age_days > 365 {
            score *= 0.9;
        }

        Ok(score.min(1.0).max(0.0))
    }

    pub fn calculate_impact(&self, cve: &CVE) -> Result<f64, String> {
        let mut score = 0.0;

        if let Some(cvss) = &cve.cvss_metrics {
            score = cvss.base_score * 0.6;

            // Confidentiality impact
            if cvss.confidentiality_impact == "High" {
                score += 0.2;
            }

            // Integrity impact
            if cvss.integrity_impact == "High" {
                score += 0.15;
            }

            // Availability impact
            if cvss.availability_impact == "High" {
                score += 0.15;
            }
        }

        // Affected systems factor
        let system_count = cve.affected_products.len();
        score += (system_count as f64 * 0.05).min(0.2);

        Ok(score.min(1.0).max(0.0))
    }
}

pub use VulnerabilityScorer as Scorer;