use chrono::Utc;
use crate::models::{CVE, CVSSAttackVector, CVSSMetrics};
use crate::config::ScoringConfig;

#[allow(dead_code)]
pub struct VulnerabilityScorer {
    pub(crate) scoring_models: Vec<crate::models::ScoringModel>,
    pub(crate) config: ScoringConfig,
}

impl VulnerabilityScorer {
    pub fn new(config: ScoringConfig) -> Self {
        Self {
            scoring_models: vec![
                crate::models::ScoringModel {
                    name: "temporal_scoring".to_string(),
                    weight: 0.3,
                    factors: vec!["age".to_string(), "patch_availability".to_string()],
                },
                crate::models::ScoringModel {
                    name: "environmental_scoring".to_string(),
                    weight: 0.4,
                    factors: vec!["asset_value".to_string(), "exposure".to_string()],
                },
                crate::models::ScoringModel {
                    name: "threat_scoring".to_string(),
                    weight: 0.3,
                    factors: vec!["actor_interest".to_string(), "exploit_maturity".to_string()],
                },
            ],
            config,
        }
    }

    pub fn calculate_exploitability(&self, cve: &CVE) -> Result<f64, String> {
        let mut score = 0.0;

        // Base exploitability and CVSS-derived modifiers
        if let Some(cvss) = &cve.cvss_metrics {
            score += cvss.base_score * self.config.base_exploitability_weight;

            // Attack vector bonus
            score += self.attack_vector_bonus(cvss.attack_vector.clone());

            // Other CVSS modifiers
            score = self.apply_exploitability_modifiers(score, cvss);
        }
        // Age factor (newer vulnerabilities are more likely to be exploited)
        let age_days = (Utc::now() - cve.published_date).num_days();
        if age_days < self.config.age_new_threshold_days {
            score += self.config.age_new_bonus;
        } else if age_days > self.config.age_old_threshold_days {
            score *= self.config.age_old_multiplier;
        }

        Ok(score.clamp(0.0, 1.0))
    }
    // ... existing code ...
    pub fn calculate_impact(&self, cve: &CVE) -> Result<f64, String> {
        let mut score = 0.0;

        if let Some(cvss) = &cve.cvss_metrics {
            score = cvss.base_score * self.config.base_impact_weight;

            // Confidentiality impact
            if cvss.confidentiality_impact.eq_ignore_ascii_case("High") {
                score += self.config.conf_high_bonus;
            }
            // Integrity impact
            if cvss.integrity_impact.eq_ignore_ascii_case("High") {
                score += self.config.integ_high_bonus;
            }
            // Availability impact
            if cvss.availability_impact.eq_ignore_ascii_case("High") {
                score += self.config.avail_high_bonus;
            }
        }

        // Affected systems factor
        let system_count = cve.affected_products.len();
        score += (system_count as f64 * self.config.affected_per_product).min(self.config.affected_max_bonus);

        Ok(score.clamp(0.0, 1.0))
    }

    // Helper: compute attack vector bonus as a clear mapping
    fn attack_vector_bonus(&self, attack_vector: CVSSAttackVector) -> f64 {
        match attack_vector {
            CVSSAttackVector::Network => self.config.attack_vector_bonus_network,
            CVSSAttackVector::Adjacent => self.config.attack_vector_bonus_adjacent,
            CVSSAttackVector::Local => self.config.attack_vector_bonus_local,
            CVSSAttackVector::Physical => self.config.attack_vector_bonus_physical,
        }
    }

    // Helper: apply additional CVSS modifiers to exploitability in a single place
    fn apply_exploitability_modifiers(&self, mut score: f64, cvss: &CVSSMetrics) -> f64 {
        // Complexity penalty
        if cvss.attack_complexity.eq_ignore_ascii_case("High") {
            score *= self.config.complexity_high_multiplier;
        }
        // Privileges bonus
        if cvss.privileges_required.eq_ignore_ascii_case("None") {
            score += self.config.priv_none_bonus;
        }
        // User interaction penalty
        if cvss.user_interaction.eq_ignore_ascii_case("Required") {
            score *= self.config.ui_required_multiplier;
        }
        score
    }
}
pub use VulnerabilityScorer as Scorer;