use std::collections::HashMap;

use crate::models::{
    CompensatingControl, RemediationAction, RemediationPriority, RemediationStrategy, RemediationTemplate,
};
use crate::config::RemediationConfig;

pub struct RemediationEngine {
    pub(crate) remediation_database: HashMap<String, Vec<RemediationTemplate>>,
    pub(crate) config: RemediationConfig,
}

impl RemediationEngine {
    pub fn new(config: RemediationConfig) -> Self {
        let mut remediation_database = HashMap::new();

        // Build remediation database from configuration
        for (vuln_type, template_configs) in &config.remediation_templates {
            let templates: Vec<RemediationTemplate> = template_configs
                .iter()
                .map(|template_config| RemediationTemplate {
                    vulnerability_pattern: template_config.vulnerability_pattern.clone(),
                    actions: template_config
                        .actions
                        .iter()
                        .map(|action_config| RemediationAction {
                            action_type: action_config.action_type.clone(),
                            description: action_config.description.clone(),
                            estimated_time: action_config.estimated_time.clone(),
                            resources_required: action_config.resources_required.clone(),
                            dependencies: action_config.dependencies.clone(),
                        })
                        .collect(),
                    success_rate: template_config.success_rate,
                })
                .collect();
            remediation_database.insert(vuln_type.clone(), templates);
        }

        Self { remediation_database, config }
    }

    pub fn generate_strategy(&self, cve: &crate::models::CVE) -> Result<RemediationStrategy, String> {
        let vuln_type = self.classify_vulnerability_for_remediation(cve)?;
        let priority = self.determine_remediation_priority(cve)?;

        let templates = self
            .remediation_database
            .get(&vuln_type)
            .cloned()
            .unwrap_or_default();

        let mut immediate_actions = Vec::new();
        let mut short_term_actions = Vec::new();
        let long_term_actions = Vec::new();

        for template in templates {
            for action in template.actions {
                match priority {
                    RemediationPriority::Critical => {
                        immediate_actions.push(action);
                    }
                    RemediationPriority::High => {
                        if action.action_type == "patch" {
                            immediate_actions.push(action);
                        } else {
                            short_term_actions.push(action);
                        }
                    }
                    _ => {
                        short_term_actions.push(action);
                    }
                }
            }
        }

        // Add compensating controls
        let compensating_controls = self.generate_compensating_controls(&vuln_type)?;

        let estimated_effort = self.estimate_remediation_effort(&immediate_actions, &short_term_actions)?;

        Ok(RemediationStrategy {
            cve_id: cve.id.clone(),
            priority,
            immediate_actions,
            short_term_actions,
            long_term_actions,
            compensating_controls,
            estimated_effort,
        })
    }

    pub fn get_immediate_mitigations(&self, cve: &crate::models::CVE) -> Result<Vec<String>, String> {
        let vuln_type = self.classify_vulnerability_for_remediation(cve)?;

        let mitigations = self.config.immediate_mitigations
            .get(&vuln_type)
            .or_else(|| self.config.immediate_mitigations.get("default"))
            .cloned()
            .unwrap_or_default();

        Ok(mitigations)
    }

    fn classify_vulnerability_for_remediation(&self, cve: &crate::models::CVE) -> Result<String, String> {
        let desc = cve.description.to_lowercase();

        if desc.contains("remote code execution") || desc.contains("rce") {
            Ok("remote_code_execution".to_string())
        } else if desc.contains("sql injection") {
            Ok("sql_injection".to_string())
        } else if desc.contains("cross-site scripting") || desc.contains("xss") {
            Ok("xss".to_string())
        } else if desc.contains("buffer overflow") {
            Ok("buffer_overflow".to_string())
        } else if desc.contains("privilege escalation") {
            Ok("privilege_escalation".to_string())
        } else {
            Ok("general".to_string())
        }
    }

    fn determine_remediation_priority(&self, cve: &crate::models::CVE) -> Result<RemediationPriority, String> {
        let base_score = cve.cvss_metrics.as_ref().map(|m| m.base_score).unwrap_or(5.0);

        if base_score >= self.config.critical_threshold {
            Ok(RemediationPriority::Critical)
        } else if base_score >= self.config.high_threshold {
            Ok(RemediationPriority::High)
        } else if base_score >= self.config.medium_threshold {
            Ok(RemediationPriority::Medium)
        } else {
            Ok(RemediationPriority::Low)
        }
    }

    fn generate_compensating_controls(&self, vuln_type: &str) -> Result<Vec<CompensatingControl>, String> {
        let control_configs = self.config.compensating_controls
            .get(vuln_type)
            .or_else(|| self.config.compensating_controls.get("default"))
            .cloned()
            .unwrap_or_default();

        let controls = control_configs
            .into_iter()
            .map(|control_config| CompensatingControl {
                control_type: control_config.control_type,
                description: control_config.description,
                effectiveness: control_config.effectiveness,
                implementation_cost: control_config.implementation_cost,
            })
            .collect();

        Ok(controls)
    }

    fn estimate_remediation_effort(
        &self,
        immediate: &[RemediationAction],
        short_term: &[RemediationAction],
    ) -> Result<crate::models::EstimatedEffort, String> {
        let total_hours = immediate
            .iter()
            .chain(short_term.iter())
            .map(|action| match action.estimated_time.as_str() {
                "2-4 hours" => 3,
                "4-8 hours" => 6,
                "8-16 hours" => 12,
                "1-2 days" => 16,
                _ => 4,
            })
            .sum::<u32>();

        let complexity = if total_hours > 40 {
            "High".to_string()
        } else if total_hours > 16 {
            "Medium".to_string()
        } else {
            "Low".to_string()
        };

        let skills = immediate
            .iter()
            .chain(short_term.iter())
            .flat_map(|action| action.resources_required.clone())
            .collect::<std::collections::HashSet<_>>()
            .into_iter()
            .collect::<Vec<_>>();

        Ok(crate::models::EstimatedEffort { hours: total_hours, cost: None, complexity, skills_required: skills })
    }
}

pub use RemediationEngine as REngine;