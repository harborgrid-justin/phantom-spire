use std::collections::HashMap;

use crate::models::{
    CompensatingControl, RemediationAction, RemediationPriority, RemediationStrategy, RemediationTemplate,
};

pub struct RemediationEngine {
    pub(crate) remediation_database: HashMap<String, Vec<RemediationTemplate>>,
}

impl RemediationEngine {
    pub fn new() -> Self {
        let mut remediation_database = HashMap::new();

        // Initialize with common remediation templates
        remediation_database.insert(
            "remote_code_execution".to_string(),
            vec![RemediationTemplate {
                vulnerability_pattern: "remote_code_execution".to_string(),
                actions: vec![
                    RemediationAction {
                        action_type: "patch".to_string(),
                        description: "Apply vendor security patch".to_string(),
                        estimated_time: "2-4 hours".to_string(),
                        resources_required: vec!["System Administrator".to_string()],
                        dependencies: vec![],
                    },
                    RemediationAction {
                        action_type: "network".to_string(),
                        description: "Implement network segmentation".to_string(),
                        estimated_time: "4-8 hours".to_string(),
                        resources_required: vec!["Network Engineer".to_string()],
                        dependencies: vec![],
                    },
                ],
                success_rate: 0.95,
            }],
        );

        remediation_database.insert(
            "sql_injection".to_string(),
            vec![RemediationTemplate {
                vulnerability_pattern: "sql_injection".to_string(),
                actions: vec![
                    RemediationAction {
                        action_type: "code".to_string(),
                        description: "Implement parameterized queries".to_string(),
                        estimated_time: "8-16 hours".to_string(),
                        resources_required: vec!["Developer".to_string()],
                        dependencies: vec![],
                    },
                    RemediationAction {
                        action_type: "waf".to_string(),
                        description: "Deploy Web Application Firewall".to_string(),
                        estimated_time: "2-4 hours".to_string(),
                        resources_required: vec!["Security Engineer".to_string()],
                        dependencies: vec![],
                    },
                ],
                success_rate: 0.90,
            }],
        );

        Self { remediation_database }
    }

    pub fn generate_strategy(&self, cve: &crate::models::CVE) -> Result<RemediationStrategy, String> {
        let vuln_type = self.classify_vulnerability_for_remediation(cve)?;
        let priority = self.determine_remediation_priority(cve)?;

        let templates = self
            .remediation_database
            .get(&vuln_type)
            .cloned()
            .unwrap_or_default();

        let mut immediate_actions = Vec::new();
        let mut short_term_actions = Vec::new();
        let long_term_actions = Vec::new();

        for template in templates {
            for action in template.actions {
                match priority {
                    RemediationPriority::Critical => {
                        immediate_actions.push(action);
                    }
                    RemediationPriority::High => {
                        if action.action_type == "patch" {
                            immediate_actions.push(action);
                        } else {
                            short_term_actions.push(action);
                        }
                    }
                    _ => {
                        short_term_actions.push(action);
                    }
                }
            }
        }

        // Add compensating controls
        let compensating_controls = self.generate_compensating_controls(&vuln_type)?;

        let estimated_effort = self.estimate_remediation_effort(&immediate_actions, &short_term_actions)?;

        Ok(RemediationStrategy {
            cve_id: cve.id.clone(),
            priority,
            immediate_actions,
            short_term_actions,
            long_term_actions,
            compensating_controls,
            estimated_effort,
        })
    }

    pub fn get_immediate_mitigations(&self, cve: &crate::models::CVE) -> Result<Vec<String>, String> {
        let vuln_type = self.classify_vulnerability_for_remediation(cve)?;

        let mut mitigations = Vec::new();

        match vuln_type.as_str() {
            "remote_code_execution" => {
                mitigations.push("Block vulnerable service ports".to_string());
                mitigations.push("Implement rate limiting".to_string());
                mitigations.push("Enable enhanced logging".to_string());
            }
            "sql_injection" => {
                mitigations.push("Enable WAF SQL injection rules".to_string());
                mitigations.push("Implement input validation".to_string());
                mitigations.push("Use prepared statements".to_string());
            }
            "xss" => {
                mitigations.push("Enable Content Security Policy".to_string());
                mitigations.push("Implement output encoding".to_string());
                mitigations.push("Enable WAF XSS protection".to_string());
            }
            _ => {
                mitigations.push("Implement general hardening measures".to_string());
                mitigations.push("Enable security monitoring".to_string());
                mitigations.push("Review access controls".to_string());
            }
        }

        Ok(mitigations)
    }

    fn classify_vulnerability_for_remediation(&self, cve: &crate::models::CVE) -> Result<String, String> {
        let desc = cve.description.to_lowercase();

        if desc.contains("remote code execution") || desc.contains("rce") {
            Ok("remote_code_execution".to_string())
        } else if desc.contains("sql injection") {
            Ok("sql_injection".to_string())
        } else if desc.contains("cross-site scripting") || desc.contains("xss") {
            Ok("xss".to_string())
        } else if desc.contains("buffer overflow") {
            Ok("buffer_overflow".to_string())
        } else if desc.contains("privilege escalation") {
            Ok("privilege_escalation".to_string())
        } else {
            Ok("general".to_string())
        }
    }

    fn determine_remediation_priority(&self, cve: &crate::models::CVE) -> Result<RemediationPriority, String> {
        let base_score = cve.cvss_metrics.as_ref().map(|m| m.base_score).unwrap_or(5.0);

        if base_score >= 9.0 {
            Ok(RemediationPriority::Critical)
        } else if base_score >= 7.0 {
            Ok(RemediationPriority::High)
        } else if base_score >= 4.0 {
            Ok(RemediationPriority::Medium)
        } else {
            Ok(RemediationPriority::Low)
        }
    }

    fn generate_compensating_controls(&self, vuln_type: &str) -> Result<Vec<CompensatingControl>, String> {
        let controls = match vuln_type {
            "remote_code_execution" => vec![
                CompensatingControl {
                    control_type: "network_segmentation".to_string(),
                    description: "Implement network segmentation to limit lateral movement".to_string(),
                    effectiveness: 0.8,
                    implementation_cost: "Medium".to_string(),
                },
                CompensatingControl {
                    control_type: "intrusion_detection".to_string(),
                    description: "Deploy intrusion detection systems".to_string(),
                    effectiveness: 0.7,
                    implementation_cost: "High".to_string(),
                },
            ],
            "sql_injection" => vec![
                CompensatingControl {
                    control_type: "database_firewall".to_string(),
                    description: "Implement database firewall".to_string(),
                    effectiveness: 0.9,
                    implementation_cost: "Medium".to_string(),
                },
                CompensatingControl {
                    control_type: "input_validation".to_string(),
                    description: "Enhanced input validation at application layer".to_string(),
                    effectiveness: 0.85,
                    implementation_cost: "Low".to_string(),
                },
            ],
            _ => vec![CompensatingControl {
                control_type: "monitoring".to_string(),
                description: "Enhanced security monitoring and alerting".to_string(),
                effectiveness: 0.6,
                implementation_cost: "Low".to_string(),
            }],
        };

        Ok(controls)
    }

    fn estimate_remediation_effort(
        &self,
        immediate: &[RemediationAction],
        short_term: &[RemediationAction],
    ) -> Result<crate::models::EstimatedEffort, String> {
        let total_hours = immediate
            .iter()
            .chain(short_term.iter())
            .map(|action| match action.estimated_time.as_str() {
                "2-4 hours" => 3,
                "4-8 hours" => 6,
                "8-16 hours" => 12,
                "1-2 days" => 16,
                _ => 4,
            })
            .sum::<u32>();

        let complexity = if total_hours > 40 {
            "High".to_string()
        } else if total_hours > 16 {
            "Medium".to_string()
        } else {
            "Low".to_string()
        };

        let skills = immediate
            .iter()
            .chain(short_term.iter())
            .flat_map(|action| action.resources_required.clone())
            .collect::<std::collections::HashSet<_>>()
            .into_iter()
            .collect::<Vec<_>>();

        Ok(crate::models::EstimatedEffort { hours: total_hours, cost: None, complexity, skills_required: skills })
    }
}

pub use RemediationEngine as REngine;