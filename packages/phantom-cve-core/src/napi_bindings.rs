use napi::bindgen_prelude::*;
use napi_derive::napi;
use crate::core::CVECore;
use crate::models::{CVE, SearchCriteria};
use crate::config::Config;
use chrono::Utc;
use serde::de::DeserializeOwned;
use serde::Serialize;
// N-API bindings for Node.js interop
#[napi]
pub struct CVECoreNapi {
    inner: CVECore,
}
#[napi]
impl CVECoreNapi {
    // Small utility helpers to reduce repetitive error handling/serde noise
    fn napi_err(ctx: &str, e: impl std::fmt::Display) -> napi::Error {
        napi::Error::from_reason(format!("{}: {}", ctx, e))
    }

    fn parse_json<T: DeserializeOwned>(ctx: &str, json: &str) -> Result<T> {
        serde_json::from_str::<T>(json).map_err(|e| Self::napi_err(&format!("Failed to parse {}", ctx), e))
    }

    fn to_json<T: Serialize>(ctx: &str, value: &T) -> Result<String> {
        serde_json::to_string(value).map_err(|e| Self::napi_err(&format!("Failed to serialize {}", ctx), e))
    }

    fn map_core_err<T>(ctx: &str, res: std::result::Result<T, String>) -> Result<T> {
        res.map_err(|e| Self::napi_err(&format!("Failed to {}", ctx), e))
    }

    #[napi(constructor)]
    pub fn new() -> Result<Self> {
        // Load configuration from file or use default
        let config = Config::load_with_default("config.toml");
        let core = Self::map_core_err("create CVE Core", CVECore::new(config))?;
        Ok(CVECoreNapi { inner: core })
    }
    #[napi]
    pub fn process_cve(&self, cve_json: String) -> Result<String> {
        let cve: CVE = Self::parse_json("CVE", &cve_json)?;
        let result = Self::map_core_err("process CVE", self.inner.process_cve(cve))?;
        Self::to_json("result", &result)
    }
    #[napi]
    pub fn batch_process_cves(&self, cves_json: String) -> Result<String> {
        let cves: Vec<CVE> = Self::parse_json("CVEs", &cves_json)?;
        let results = Self::map_core_err("batch process CVEs", self.inner.batch_process_cves(cves))?;
        Self::to_json("results", &results)
    }
    #[napi]
    pub fn search_vulnerabilities(&self, criteria_json: String) -> Result<String> {
        let criteria: SearchCriteria = Self::parse_json("search criteria", &criteria_json)?;
        let results = Self::map_core_err("search vulnerabilities", self.inner.search_vulnerabilities(criteria))?;
        Self::to_json("search results", &results)
    }
    #[napi]
    pub fn get_exploit_timeline(&self, cve_id: String) -> Result<String> {
        let timeline = Self::map_core_err("get exploit timeline", self.inner.get_exploit_timeline(&cve_id))?;
        Self::to_json("timeline", &timeline)
    }
    #[napi]
    pub fn get_remediation_strategy(&self, cve_json: String) -> Result<String> {
        let cve: CVE = Self::parse_json("CVE", &cve_json)?;
        let strategy = Self::map_core_err("get remediation strategy", self.inner.get_remediation_strategy(&cve))?;
        Self::to_json("strategy", &strategy)
    }
    #[napi]
    pub fn get_health_status(&self) -> Result<String> {
        // Simple health check
        let status = serde_json::json!({
            "status": "healthy",
            "timestamp": Utc::now().to_rfc3339(),
            "version": env!("CARGO_PKG_VERSION")
        });
        Self::to_json("health status", &status)
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    #[test]
    fn test_cve_core_creation() {
        let config = Config::default();
        let core = CVECore::new(config);
        assert!(core.is_ok());
    }
    #[test]
    fn test_cve_processing() {
        let config = Config::default();
        let core = CVECore::new(config).unwrap();
        let test_cve = CVE {
            id: "CVE-2024-12345".to_string(),
            description: "Test vulnerability".to_string(),
            published_date: Utc::now(),
            last_modified_date: Utc::now(),
            cvss_metrics: None,
            cwe: None,
            affected_products: vec![crate::models::AffectedProduct {
                vendor: "Test Vendor".to_string(),
                product: "Test Product".to_string(),
                version: "1.0.0".to_string(),
                version_start_including: None,
                version_end_including: None,
                version_start_excluding: None,
                version_end_excluding: None,
            }],
            references: vec![],
            status: "published".to_string(),
            assigner: "test@example.com".to_string(),
            tags: vec![],
        };
        let result = core.process_cve(test_cve);
        assert!(result.is_ok());
    }
}
