use napi::bindgen_prelude::*;
use napi_derive::napi;

use crate::core::CVECore;
use crate::models::{CVE, SearchCriteria};

// N-API bindings for Node.js interop
#[napi]
pub struct CVECoreNapi {
    inner: CVECore,
}

#[napi]
impl CVECoreNapi {
    #[napi(constructor)]
    pub fn new() -> Result<Self> {
        let core = CVECore::new().map_err(|e| napi::Error::from_reason(format!(
            "Failed to create CVE Core: {}",
            e
        )))?;

        Ok(CVECoreNapi { inner: core })
    }

    #[napi]
    pub fn process_cve(&self, cve_json: String) -> Result<String> {
        let cve: CVE = serde_json::from_str(&cve_json)
            .map_err(|e| napi::Error::from_reason(format!("Failed to parse CVE: {}", e)))?;

        let result = self
            .inner
            .process_cve(cve)
            .map_err(|e| napi::Error::from_reason(format!("Failed to process CVE: {}", e)))?;

        serde_json::to_string(&result)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize result: {}", e)))
    }

    #[napi]
    pub fn batch_process_cves(&self, cves_json: String) -> Result<String> {
        let cves: Vec<CVE> = serde_json::from_str(&cves_json)
            .map_err(|e| napi::Error::from_reason(format!("Failed to parse CVEs: {}", e)))?;

        let results = self
            .inner
            .batch_process_cves(cves)
            .map_err(|e| napi::Error::from_reason(format!(
                "Failed to batch process CVEs: {}",
                e
            )))?;

        serde_json::to_string(&results)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize results: {}", e)))
    }

    #[napi]
    pub fn search_vulnerabilities(&self, criteria_json: String) -> Result<String> {
        let criteria: SearchCriteria = serde_json::from_str(&criteria_json).map_err(|e| {
            napi::Error::from_reason(format!("Failed to parse search criteria: {}", e))
        })?;

        let results = self
            .inner
            .search_vulnerabilities(criteria)
            .map_err(|e| napi::Error::from_reason(format!(
                "Failed to search vulnerabilities: {}",
                e
            )))?;

        serde_json::to_string(&results).map_err(|e| {
            napi::Error::from_reason(format!("Failed to serialize search results: {}", e))
        })
    }

    #[napi]
    pub fn get_exploit_timeline(&self, cve_id: String) -> Result<String> {
        let timeline = self
            .inner
            .get_exploit_timeline(&cve_id)
            .map_err(|e| napi::Error::from_reason(format!(
                "Failed to get exploit timeline: {}",
                e
            )))?;

        serde_json::to_string(&timeline)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize timeline: {}", e)))
    }

    #[napi]
    pub fn get_remediation_strategy(&self, cve_json: String) -> Result<String> {
        let cve: CVE = serde_json::from_str(&cve_json)
            .map_err(|e| napi::Error::from_reason(format!("Failed to parse CVE: {}", e)))?;

        let strategy = self
            .inner
            .get_remediation_strategy(&cve)
            .map_err(|e| napi::Error::from_reason(format!(
                "Failed to get remediation strategy: {}",
                e
            )))?;

        serde_json::to_string(&strategy)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize strategy: {}", e)))
    }

    #[napi]
    pub fn get_health_status(&self) -> Result<String> {
        // Simple health check
        let status = serde_json::json!({
            "status": "healthy",
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "version": env!("CARGO_PKG_VERSION")
        });

        serde_json::to_string(&status).map_err(|e| {
            napi::Error::from_reason(format!("Failed to serialize health status: {}", e))
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;

    #[test]
    fn test_cve_core_creation() {
        let core = CVECore::new();
        assert!(core.is_ok());
    }

    #[test]
    fn test_cve_processing() {
        let core = CVECore::new().unwrap();

        let test_cve = CVE {
            id: "CVE-2024-12345".to_string(),
            description: "Test vulnerability".to_string(),
            published_date: Utc::now(),
            last_modified_date: Utc::now(),
            cvss_metrics: None,
            cwe: None,
            affected_products: vec![crate::models::AffectedProduct {
                vendor: "Test Vendor".to_string(),
                product: "Test Product".to_string(),
                version: "1.0.0".to_string(),
                version_start_including: None,
                version_end_including: None,
                version_start_excluding: None,
                version_end_excluding: None,
            }],
            references: vec![],
            status: "published".to_string(),
            assigner: "test@example.com".to_string(),
            tags: vec![],
        };

        let result = core.process_cve(test_cve);
        assert!(result.is_ok());
    }
}
