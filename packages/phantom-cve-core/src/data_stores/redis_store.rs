//! Redis Data Store Implementation
//! 
//! High-performance Redis-based data store for CVE data with caching capabilities

use async_trait::async_trait;
use redis::{Client, aio::ConnectionManager, RedisError, AsyncCommands, RedisResult};
use crate::models::{CVE, ExploitTimeline, RemediationStrategy, SearchCriteria as CVESearchCriteria};
use super::{
    DataStoreResult, DataStoreError, TenantContext, SearchResults, 
    DataStoreMetrics, BulkOperationResult, Pagination,
    CVEDataStore, CVEStore, ExploitStore, RemediationStore, 
    ComprehensiveCVEStore, RedisConfig, TenantData, DataSerializer
};
use std::time::{Duration, Instant};
use chrono::Utc;
use futures::future::try_join_all;
use log::{info, warn, error, debug};

/// Redis-based CVE data store implementation
pub struct RedisDataStore {
    connection_manager: Option<ConnectionManager>,
    config: RedisConfig,
    is_connected: bool,
}

impl RedisDataStore {
    /// Create a new Redis data store instance
    pub fn new(config: RedisConfig) -> Self {
        Self {
            connection_manager: None,
            config,
            is_connected: false,
        }
    }
    
    /// Get Redis connection manager
    async fn get_connection(&self) -> DataStoreResult<&ConnectionManager> {
        self.connection_manager
            .as_ref()
            .ok_or_else(|| DataStoreError::Connection("Redis not connected".to_string()))
    }
    
    /// Generate cache key with proper prefix and tenant isolation
    fn cache_key(&self, key_type: &str, id: &str, context: &TenantContext) -> String {
        format!("{}{}:{}:{}", self.config.key_prefix, context.tenant_id, key_type, id)
    }
    
    /// Generate search pattern for keys
    fn search_pattern(&self, key_type: &str, pattern: &str, context: &TenantContext) -> String {
        format!("{}{}:{}:{}", self.config.key_prefix, context.tenant_id, key_type, pattern)
    }
    
    /// Store data with TTL
    async fn store_with_ttl<T: serde::Serialize>(
        &self,
        key: &str,
        data: &T,
        ttl_seconds: u64,
    ) -> DataStoreResult<()> {
        let mut conn = self.get_connection().await?.clone();
        let serialized = DataSerializer::to_redis_value(data)?;
        
        conn.set_ex(key, serialized, ttl_seconds as usize)
            .await
            .map_err(|e| DataStoreError::Database(e.to_string()))?;
        
        Ok(())
    }
    
    /// Get data with deserialization
    async fn get_data<T: for<'de> serde::Deserialize<'de>>(
        &self,
        key: &str,
    ) -> DataStoreResult<Option<T>> {
        let mut conn = self.get_connection().await?.clone();
        
        let data: Option<Vec<u8>> = conn.get(key)
            .await
            .map_err(|e| DataStoreError::Database(e.to_string()))?;
        
        match data {
            Some(bytes) => {
                let deserialized = DataSerializer::from_redis_value::<T>(&bytes)?;
                Ok(Some(deserialized))
            }
            None => Ok(None),
        }
    }
    
    /// Search keys by pattern and deserialize values
    async fn search_by_pattern<T: for<'de> serde::Deserialize<'de>>(
        &self,
        pattern: &str,
        criteria: &CVESearchCriteria,
    ) -> DataStoreResult<SearchResults<T>> {
        let start_time = Instant::now();
        let mut conn = self.get_connection().await?.clone();
        
        // Get all keys matching pattern
        let keys: Vec<String> = conn.keys(pattern)
            .await
            .map_err(|e| DataStoreError::Database(e.to_string()))?;
        
        let total = keys.len();
        
        // Apply pagination (simplified for this implementation)
        let offset = 0;
        let limit = 100;
        
        let paginated_keys: Vec<String> = keys
            .into_iter()
            .skip(offset)
            .take(limit)
            .collect();
        
        // Fetch data for paginated keys
        let mut items = Vec::new();
        for key in &paginated_keys {
            if let Some(data) = self.get_data::<TenantData<T>>(key).await? {
                items.push(data.data);
            }
        }
        
        let page_size = limit;
        let page = offset / page_size;
        let total_pages = (total + page_size - 1) / page_size;
        
        let pagination = Pagination {
            page,
            size: page_size,
            total,
            total_pages,
        };
        
        let took_ms = start_time.elapsed().as_millis() as u64;
        
        Ok(SearchResults {
            items,
            pagination,
            took_ms,
        })
    }
    
    /// Delete key
    async fn delete_key(&self, key: &str) -> DataStoreResult<()> {
        let mut conn = self.get_connection().await?.clone();
        
        conn.del(key)
            .await
            .map_err(|e| DataStoreError::Database(e.to_string()))?;
        
        Ok(())
    }
    
    /// Get key count by pattern
    async fn count_keys(&self, pattern: &str) -> DataStoreResult<usize> {
        let mut conn = self.get_connection().await?.clone();
        
        let keys: Vec<String> = conn.keys(pattern)
            .await
            .map_err(|e| DataStoreError::Database(e.to_string()))?;
        
        Ok(keys.len())
    }
}

#[async_trait]
impl CVEDataStore for RedisDataStore {
    async fn initialize(&mut self) -> DataStoreResult<()> {
        info!("Initializing Redis data store with URL: {}", self.config.url);
        
        let client = Client::open(self.config.url.clone())
            .map_err(|e| DataStoreError::Connection(e.to_string()))?;
        
        let connection_manager = ConnectionManager::new(client)
            .await
            .map_err(|e| DataStoreError::Connection(e.to_string()))?;
        
        self.connection_manager = Some(connection_manager);
        self.is_connected = true;
        
        info!("Redis data store initialized successfully");
        Ok(())
    }
    
    async fn close(&mut self) -> DataStoreResult<()> {
        info!("Closing Redis data store connection");
        self.connection_manager = None;
        self.is_connected = false;
        Ok(())
    }
    
    async fn health_check(&self) -> DataStoreResult<bool> {
        if !self.is_connected {
            return Ok(false);
        }
        
        let mut conn = self.get_connection().await?.clone();
        
        match redis::cmd("PING").query_async::<_, String>(&mut conn).await {
            Ok(_) => Ok(true),
            Err(e) => {
                warn!("Redis health check failed: {}", e);
                Ok(false)
            }
        }
    }
    
    async fn get_metrics(&self, context: &TenantContext) -> DataStoreResult<DataStoreMetrics> {
        let cves_count = self.count_keys(&self.search_pattern("cves", "*", context)).await?;
        let exploits_count = self.count_keys(&self.search_pattern("exploits", "*", context)).await?;
        let remediations_count = self.count_keys(&self.search_pattern("remediations", "*", context)).await?;
        
        // Get Redis memory info
        let mut conn = self.get_connection().await?.clone();
        let info: String = redis::cmd("INFO").arg("memory").query_async(&mut conn)
            .await
            .map_err(|e| DataStoreError::Database(e.to_string()))?;
        
        // Parse memory usage from info (simplified)
        let storage_size_bytes = info
            .lines()
            .find(|line| line.starts_with("used_memory:"))
            .and_then(|line| line.split(':').nth(1))
            .and_then(|size| size.parse::<u64>().ok())
            .unwrap_or(0);
        
        Ok(DataStoreMetrics {
            total_cves: cves_count,
            total_exploits: exploits_count,
            total_remediations: remediations_count,
            storage_size_bytes,
            last_updated: Utc::now(),
        })
    }
}

#[async_trait]
impl CVEStore for RedisDataStore {
    async fn store_cve(&self, cve: &CVE, context: &TenantContext) -> DataStoreResult<String> {
        let key = self.cache_key("cves", &cve.cve_metadata.cve_id, context);
        let tenant_data = TenantData::new(cve.clone(), context);
        
        self.store_with_ttl(&key, &tenant_data, 3600).await?; // 1 hour TTL
        
        debug!("Stored CVE {} for tenant {}", cve.cve_metadata.cve_id, context.tenant_id);
        Ok(cve.cve_metadata.cve_id.clone())
    }
    
    async fn get_cve(&self, id: &str, context: &TenantContext) -> DataStoreResult<Option<CVE>> {
        let key = self.cache_key("cves", id, context);
        
        match self.get_data::<TenantData<CVE>>(&key).await? {
            Some(tenant_data) => Ok(Some(tenant_data.data)),
            None => Ok(None),
        }
    }
    
    async fn update_cve(&self, cve: &CVE, context: &TenantContext) -> DataStoreResult<()> {
        // For Redis, update is the same as store (replace)
        self.store_cve(cve, context).await?;
        Ok(())
    }
    
    async fn delete_cve(&self, id: &str, context: &TenantContext) -> DataStoreResult<()> {
        let key = self.cache_key("cves", id, context);
        self.delete_key(&key).await
    }
    
    async fn search_cves(&self, criteria: &CVESearchCriteria, context: &TenantContext) -> DataStoreResult<SearchResults<CVE>> {
        let pattern = self.search_pattern("cves", "*", context);
        self.search_by_pattern(&pattern, criteria).await
    }
    
    async fn bulk_store_cves(&self, cves: &[CVE], context: &TenantContext) -> DataStoreResult<BulkOperationResult> {
        let mut success_count = 0;
        let mut error_count = 0;
        let mut errors = Vec::new();
        let mut processed_ids = Vec::new();
        
        for cve in cves {
            match self.store_cve(cve, context).await {
                Ok(id) => {
                    success_count += 1;
                    processed_ids.push(id);
                }
                Err(e) => {
                    error_count += 1;
                    errors.push(format!("Failed to store CVE {}: {}", cve.cve_metadata.cve_id, e));
                }
            }
        }
        
        Ok(BulkOperationResult {
            success_count,
            error_count,
            errors,
            processed_ids,
        })
    }
    
    async fn list_cve_ids(&self, context: &TenantContext) -> DataStoreResult<Vec<String>> {
        let pattern = self.search_pattern("cves", "*", context);
        let mut conn = self.get_connection().await?.clone();
        
        let keys: Vec<String> = conn.keys(pattern)
            .await
            .map_err(|e| DataStoreError::Database(e.to_string()))?;
        
        // Extract IDs from keys
        let ids: Vec<String> = keys
            .into_iter()
            .filter_map(|key| {
                key.split(':').last().map(|id| id.to_string())
            })
            .collect();
        
        Ok(ids)
    }
}

#[async_trait]
impl ExploitStore for RedisDataStore {
    async fn store_exploit(&self, exploit: &ExploitTimeline, context: &TenantContext) -> DataStoreResult<String> {
        let key = self.cache_key("exploits", &exploit.cve_id, context);
        let tenant_data = TenantData::new(exploit.clone(), context);
        
        self.store_with_ttl(&key, &tenant_data, 3600).await?;
        
        debug!("Stored exploit {} for tenant {}", exploit.cve_id, context.tenant_id);
        Ok(exploit.cve_id.clone())
    }
    
    async fn get_exploit(&self, id: &str, context: &TenantContext) -> DataStoreResult<Option<ExploitTimeline>> {
        let key = self.cache_key("exploits", id, context);
        
        match self.get_data::<TenantData<ExploitTimeline>>(&key).await? {
            Some(tenant_data) => Ok(Some(tenant_data.data)),
            None => Ok(None),
        }
    }
    
    async fn delete_exploit(&self, id: &str, context: &TenantContext) -> DataStoreResult<()> {
        let key = self.cache_key("exploits", id, context);
        self.delete_key(&key).await
    }
    
    async fn search_exploits(&self, criteria: &CVESearchCriteria, context: &TenantContext) -> DataStoreResult<SearchResults<ExploitTimeline>> {
        let pattern = self.search_pattern("exploits", "*", context);
        self.search_by_pattern(&pattern, criteria).await
    }
}

#[async_trait]
impl RemediationStore for RedisDataStore {
    async fn store_remediation(&self, remediation: &RemediationStrategy, context: &TenantContext) -> DataStoreResult<String> {
        let key = self.cache_key("remediations", &remediation.cve_id, context);
        let tenant_data = TenantData::new(remediation.clone(), context);
        
        self.store_with_ttl(&key, &tenant_data, 3600).await?;
        
        debug!("Stored remediation {} for tenant {}", remediation.cve_id, context.tenant_id);
        Ok(remediation.cve_id.clone())
    }
    
    async fn get_remediation(&self, id: &str, context: &TenantContext) -> DataStoreResult<Option<RemediationStrategy>> {
        let key = self.cache_key("remediations", id, context);
        
        match self.get_data::<TenantData<RemediationStrategy>>(&key).await? {
            Some(tenant_data) => Ok(Some(tenant_data.data)),
            None => Ok(None),
        }
    }
    
    async fn delete_remediation(&self, id: &str, context: &TenantContext) -> DataStoreResult<()> {
        let key = self.cache_key("remediations", id, context);
        self.delete_key(&key).await
    }
    
    async fn search_remediations(&self, criteria: &CVESearchCriteria, context: &TenantContext) -> DataStoreResult<SearchResults<RemediationStrategy>> {
        let pattern = self.search_pattern("remediations", "*", context);
        self.search_by_pattern(&pattern, criteria).await
    }
}

#[async_trait]
impl ComprehensiveCVEStore for RedisDataStore {
    fn store_type(&self) -> &'static str {
        "redis"
    }
    
    fn supports_multi_tenancy(&self) -> bool {
        true
    }
    
    fn supports_full_text_search(&self) -> bool {
        false // Redis doesn't support full-text search natively
    }
    
    fn supports_transactions(&self) -> bool {
        true // Redis supports transactions
    }
}