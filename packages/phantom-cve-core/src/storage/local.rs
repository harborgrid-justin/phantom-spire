// Local file-based storage implementation
use async_trait::async_trait;
use chrono::Utc;
use serde_json;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use tokio::fs as async_fs;
use tokio::sync::RwLock;

use crate::config::LocalStorageConfig;
use crate::models::{CVE, CVEAnalysisResult, SearchCriteria};
use super::traits::{Storage, StorageStatistics, HealthStatus};
use super::StorageError;

/// Local file-based storage implementation
pub struct LocalStorage {
    data_dir: PathBuf,
    format: FileFormat,
    max_file_size: u64,
    // In-memory cache for better performance
    cve_cache: RwLock<HashMap<String, CVE>>,
    analysis_cache: RwLock<HashMap<String, CVEAnalysisResult>>,
}

#[derive(Debug, Clone)]
enum FileFormat {
    Json,
    Toml,
}

impl FileFormat {
    fn from_str(s: &str) -> Result<Self, StorageError> {
        match s.to_lowercase().as_str() {
            "json" => Ok(FileFormat::Json),
            "toml" => Ok(FileFormat::Toml),
            _ => Err(StorageError::ConfigurationError(
                format!("Unsupported file format: {}", s)
            ))
        }
    }
    
    fn extension(&self) -> &'static str {
        match self {
            FileFormat::Json => "json",
            FileFormat::Toml => "toml",
        }
    }
}

impl LocalStorage {
    /// Create a new local storage instance
    pub fn new(config: &LocalStorageConfig) -> Result<Self, StorageError> {
        let data_dir = PathBuf::from(&config.data_directory);
        let format = FileFormat::from_str(&config.file_format)?;
        
        // Create data directory if it doesn't exist
        if !data_dir.exists() {
            fs::create_dir_all(&data_dir).map_err(|e| {
                StorageError::IoError(format!("Failed to create data directory: {}", e))
            })?;
        }
        
        // Create subdirectories for CVEs and analyses
        let cve_dir = data_dir.join("cves");
        let analysis_dir = data_dir.join("analyses");
        
        for dir in [&cve_dir, &analysis_dir] {
            if !dir.exists() {
                fs::create_dir_all(dir).map_err(|e| {
                    StorageError::IoError(format!("Failed to create subdirectory: {}", e))
                })?;
            }
        }
        
        Ok(LocalStorage {
            data_dir,
            format,
            max_file_size: config.max_file_size_mb * 1024 * 1024, // Convert to bytes
            cve_cache: RwLock::new(HashMap::new()),
            analysis_cache: RwLock::new(HashMap::new()),
        })
    }
    
    /// Get the file path for a CVE record
    fn cve_path(&self, cve_id: &str) -> PathBuf {
        let filename = format!("{}.{}", self.sanitize_filename(cve_id), self.format.extension());
        self.data_dir.join("cves").join(filename)
    }
    
    /// Get the file path for an analysis result
    fn analysis_path(&self, cve_id: &str) -> PathBuf {
        let filename = format!("{}.{}", self.sanitize_filename(cve_id), self.format.extension());
        self.data_dir.join("analyses").join(filename)
    }
    
    /// Sanitize filename to be safe for filesystem
    fn sanitize_filename(&self, name: &str) -> String {
        name.replace(['/', '\\', ':', '*', '?', '"', '<', '>', '|'], "_")
    }
    
    /// Serialize data to string based on format
    fn serialize<T: serde::Serialize>(&self, data: &T) -> Result<String, StorageError> {
        match self.format {
            FileFormat::Json => serde_json::to_string_pretty(data)
                .map_err(|e| StorageError::SerializationError(format!("JSON serialization error: {}", e))),
            FileFormat::Toml => toml::to_string_pretty(data)
                .map_err(|e| StorageError::SerializationError(format!("TOML serialization error: {}", e))),
        }
    }
    
    /// Deserialize data from string based on format
    fn deserialize<T: serde::de::DeserializeOwned>(&self, data: &str) -> Result<T, StorageError> {
        match self.format {
            FileFormat::Json => serde_json::from_str(data)
                .map_err(|e| StorageError::SerializationError(format!("JSON deserialization error: {}", e))),
            FileFormat::Toml => toml::from_str(data)
                .map_err(|e| StorageError::SerializationError(format!("TOML deserialization error: {}", e))),
        }
    }
    
    /// Write data to file with size check
    async fn write_file(&self, path: &Path, content: &str) -> Result<(), StorageError> {
        if content.len() as u64 > self.max_file_size {
            return Err(StorageError::ConfigurationError(
                format!("File size {} exceeds maximum allowed size {}", content.len(), self.max_file_size)
            ));
        }
        
        async_fs::write(path, content).await
            .map_err(|e| StorageError::IoError(format!("Failed to write file {}: {}", path.display(), e)))
    }
    
    /// Read data from file
    async fn read_file(&self, path: &Path) -> Result<String, StorageError> {
        if !path.exists() {
            return Err(StorageError::NotFound(format!("File not found: {}", path.display())));
        }
        
        async_fs::read_to_string(path).await
            .map_err(|e| StorageError::IoError(format!("Failed to read file {}: {}", path.display(), e)))
    }
    
    /// Check if search criteria matches a CVE
    fn matches_criteria(&self, cve: &CVE, criteria: &SearchCriteria) -> bool {
        // CVE ID filter
        if let Some(ref cve_id) = criteria.cve_id {
            if !cve.id.contains(cve_id) {
                return false;
            }
        }
        
        // Vendor filter
        if let Some(ref vendor) = criteria.vendor {
            let vendor_match = cve.affected_products.iter()
                .any(|p| p.vendor.to_lowercase().contains(&vendor.to_lowercase()));
            if !vendor_match {
                return false;
            }
        }
        
        // Product filter
        if let Some(ref product) = criteria.product {
            let product_match = cve.affected_products.iter()
                .any(|p| p.product.to_lowercase().contains(&product.to_lowercase()));
            if !product_match {
                return false;
            }
        }
        
        // Severity range filter
        if let Some(ref cvss) = cve.cvss_metrics {
            if let Some(min_severity) = criteria.severity_min {
                if cvss.base_score < min_severity {
                    return false;
                }
            }
            if let Some(max_severity) = criteria.severity_max {
                if cvss.base_score > max_severity {
                    return false;
                }
            }
        }
        
        // Date range filter
        if let Some((start_date, end_date)) = criteria.date_range {
            if cve.published_date < start_date || cve.published_date > end_date {
                return false;
            }
        }
        
        // Tags filter
        if !criteria.tags.is_empty() {
            let has_matching_tag = criteria.tags.iter()
                .any(|tag| cve.tags.iter().any(|cve_tag| cve_tag.to_lowercase().contains(&tag.to_lowercase())));
            if !has_matching_tag {
                return false;
            }
        }
        
        true
    }
}

#[async_trait]
impl Storage for LocalStorage {
    async fn store_analysis(&self, result: &CVEAnalysisResult) -> Result<(), StorageError> {
        let path = self.analysis_path(&result.cve.id);
        let content = self.serialize(result)?;
        self.write_file(&path, &content).await?;
        
        // Update cache
        let mut cache = self.analysis_cache.write().await;
        cache.insert(result.cve.id.clone(), result.clone());
        
        Ok(())
    }
    
    async fn store_analysis_batch(&self, results: &[CVEAnalysisResult]) -> Result<(), StorageError> {
        for result in results {
            self.store_analysis(result).await?;
        }
        Ok(())
    }
    
    async fn get_analysis(&self, cve_id: &str) -> Result<Option<CVEAnalysisResult>, StorageError> {
        // Check cache first
        {
            let cache = self.analysis_cache.read().await;
            if let Some(result) = cache.get(cve_id) {
                return Ok(Some(result.clone()));
            }
        }
        
        // Try to read from file
        let path = self.analysis_path(cve_id);
        match self.read_file(&path).await {
            Ok(content) => {
                let result: CVEAnalysisResult = self.deserialize(&content)?;
                
                // Update cache
                let mut cache = self.analysis_cache.write().await;
                cache.insert(cve_id.to_string(), result.clone());
                
                Ok(Some(result))
            },
            Err(StorageError::NotFound(_)) => Ok(None),
            Err(e) => Err(e),
        }
    }
    
    async fn get_analysis_batch(&self, cve_ids: &[String]) -> Result<Vec<CVEAnalysisResult>, StorageError> {
        let mut results = Vec::new();
        for cve_id in cve_ids {
            if let Some(result) = self.get_analysis(cve_id).await? {
                results.push(result);
            }
        }
        Ok(results)
    }
    
    async fn search_analyses(&self, criteria: &SearchCriteria) -> Result<Vec<CVEAnalysisResult>, StorageError> {
        let analysis_dir = self.data_dir.join("analyses");
        let mut results = Vec::new();
        
        let mut entries = async_fs::read_dir(&analysis_dir).await
            .map_err(|e| StorageError::IoError(format!("Failed to read analyses directory: {}", e)))?;
        
        while let Some(entry) = entries.next_entry().await
            .map_err(|e| StorageError::IoError(format!("Failed to read directory entry: {}", e)))? {
            
            if let Ok(content) = self.read_file(&entry.path()).await {
                if let Ok(result) = self.deserialize::<CVEAnalysisResult>(&content) {
                    if self.matches_criteria(&result.cve, criteria) {
                        results.push(result);
                    }
                }
            }
        }
        
        Ok(results)
    }
    
    async fn store_cve(&self, cve: &CVE) -> Result<(), StorageError> {
        let path = self.cve_path(&cve.id);
        let content = self.serialize(cve)?;
        self.write_file(&path, &content).await?;
        
        // Update cache
        let mut cache = self.cve_cache.write().await;
        cache.insert(cve.id.clone(), cve.clone());
        
        Ok(())
    }
    
    async fn store_cve_batch(&self, cves: &[CVE]) -> Result<(), StorageError> {
        for cve in cves {
            self.store_cve(cve).await?;
        }
        Ok(())
    }
    
    async fn get_cve(&self, cve_id: &str) -> Result<Option<CVE>, StorageError> {
        // Check cache first
        {
            let cache = self.cve_cache.read().await;
            if let Some(cve) = cache.get(cve_id) {
                return Ok(Some(cve.clone()));
            }
        }
        
        // Try to read from file
        let path = self.cve_path(cve_id);
        match self.read_file(&path).await {
            Ok(content) => {
                let cve: CVE = self.deserialize(&content)?;
                
                // Update cache
                let mut cache = self.cve_cache.write().await;
                cache.insert(cve_id.to_string(), cve.clone());
                
                Ok(Some(cve))
            },
            Err(StorageError::NotFound(_)) => Ok(None),
            Err(e) => Err(e),
        }
    }
    
    async fn get_cve_batch(&self, cve_ids: &[String]) -> Result<Vec<CVE>, StorageError> {
        let mut results = Vec::new();
        for cve_id in cve_ids {
            if let Some(cve) = self.get_cve(cve_id).await? {
                results.push(cve);
            }
        }
        Ok(results)
    }
    
    async fn search_cves(&self, criteria: &SearchCriteria) -> Result<Vec<CVE>, StorageError> {
        let cve_dir = self.data_dir.join("cves");
        let mut results = Vec::new();
        
        let mut entries = async_fs::read_dir(&cve_dir).await
            .map_err(|e| StorageError::IoError(format!("Failed to read CVEs directory: {}", e)))?;
        
        while let Some(entry) = entries.next_entry().await
            .map_err(|e| StorageError::IoError(format!("Failed to read directory entry: {}", e)))? {
            
            if let Ok(content) = self.read_file(&entry.path()).await {
                if let Ok(cve) = self.deserialize::<CVE>(&content) {
                    if self.matches_criteria(&cve, criteria) {
                        results.push(cve);
                    }
                }
            }
        }
        
        Ok(results)
    }
    
    async fn list_cve_ids(&self) -> Result<Vec<String>, StorageError> {
        let cve_dir = self.data_dir.join("cves");
        let mut ids = Vec::new();
        
        let mut entries = async_fs::read_dir(&cve_dir).await
            .map_err(|e| StorageError::IoError(format!("Failed to read CVEs directory: {}", e)))?;
        
        while let Some(entry) = entries.next_entry().await
            .map_err(|e| StorageError::IoError(format!("Failed to read directory entry: {}", e)))? {
            
            if let Some(file_stem) = entry.path().file_stem() {
                if let Some(id) = file_stem.to_str() {
                    ids.push(id.to_string());
                }
            }
        }
        
        Ok(ids)
    }
    
    async fn list_analysis_ids(&self) -> Result<Vec<String>, StorageError> {
        let analysis_dir = self.data_dir.join("analyses");
        let mut ids = Vec::new();
        
        let mut entries = async_fs::read_dir(&analysis_dir).await
            .map_err(|e| StorageError::IoError(format!("Failed to read analyses directory: {}", e)))?;
        
        while let Some(entry) = entries.next_entry().await
            .map_err(|e| StorageError::IoError(format!("Failed to read directory entry: {}", e)))? {
            
            if let Some(file_stem) = entry.path().file_stem() {
                if let Some(id) = file_stem.to_str() {
                    ids.push(id.to_string());
                }
            }
        }
        
        Ok(ids)
    }
    
    async fn delete_analysis(&self, cve_id: &str) -> Result<bool, StorageError> {
        let path = self.analysis_path(cve_id);
        
        if !path.exists() {
            return Ok(false);
        }
        
        async_fs::remove_file(&path).await
            .map_err(|e| StorageError::IoError(format!("Failed to delete analysis file: {}", e)))?;
        
        // Remove from cache
        let mut cache = self.analysis_cache.write().await;
        cache.remove(cve_id);
        
        Ok(true)
    }
    
    async fn delete_cve(&self, cve_id: &str) -> Result<bool, StorageError> {
        let path = self.cve_path(cve_id);
        
        if !path.exists() {
            return Ok(false);
        }
        
        async_fs::remove_file(&path).await
            .map_err(|e| StorageError::IoError(format!("Failed to delete CVE file: {}", e)))?;
        
        // Remove from cache
        let mut cache = self.cve_cache.write().await;
        cache.remove(cve_id);
        
        Ok(true)
    }
    
    async fn get_statistics(&self) -> Result<StorageStatistics, StorageError> {
        let cve_ids = self.list_cve_ids().await?;
        let analysis_ids = self.list_analysis_ids().await?;
        
        // Calculate storage size
        let mut total_size = 0u64;
        for subdir in ["cves", "analyses"] {
            let dir = self.data_dir.join(subdir);
            if let Ok(mut entries) = async_fs::read_dir(&dir).await {
                while let Ok(Some(entry)) = entries.next_entry().await {
                    if let Ok(metadata) = entry.metadata().await {
                        total_size += metadata.len();
                    }
                }
            }
        }
        
        Ok(StorageStatistics {
            total_cves: cve_ids.len() as u64,
            total_analyses: analysis_ids.len() as u64,
            storage_size_bytes: total_size,
            last_updated: Utc::now(),
        })
    }
    
    async fn health_check(&self) -> Result<HealthStatus, StorageError> {
        // Check if data directory exists and is writable
        if !self.data_dir.exists() {
            return Ok(HealthStatus::Unhealthy {
                reason: "Data directory does not exist".to_string()
            });
        }
        
        // Try to write a test file
        let test_path = self.data_dir.join("health_check.tmp");
        match async_fs::write(&test_path, "health_check").await {
            Ok(_) => {
                // Clean up test file
                let _ = async_fs::remove_file(&test_path).await;
                Ok(HealthStatus::Healthy)
            },
            Err(e) => Ok(HealthStatus::Unhealthy {
                reason: format!("Cannot write to data directory: {}", e)
            }),
        }
    }
    
    async fn initialize(&self) -> Result<(), StorageError> {
        // Create directories if they don't exist
        for subdir in ["cves", "analyses"] {
            let dir = self.data_dir.join(subdir);
            if !dir.exists() {
                async_fs::create_dir_all(&dir).await
                    .map_err(|e| StorageError::IoError(format!("Failed to create directory {}: {}", dir.display(), e)))?;
            }
        }
        Ok(())
    }
    
    async fn close(&self) -> Result<(), StorageError> {
        // Clear caches
        {
            let mut cve_cache = self.cve_cache.write().await;
            cve_cache.clear();
        }
        {
            let mut analysis_cache = self.analysis_cache.write().await;
            analysis_cache.clear();
        }
        Ok(())
    }
}