//! Vulnerability Feed Integrations
//!
//! Integration modules for external CVE and vulnerability data sources

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use crate::models::CVE;
use super::{HealthCheck, IntegrationStatus};

/// Common interface for vulnerability feed integrations
#[async_trait]
pub trait VulnerabilityFeed: Send + Sync {
    /// Get the feed name
    fn feed_name(&self) -> &'static str;
    
    /// Initialize the feed connection
    async fn initialize(&mut self) -> Result<(), String>;
    
    /// Fetch recent vulnerabilities
    async fn fetch_recent(&self, since: DateTime<Utc>) -> Result<Vec<CVE>, String>;
    
    /// Fetch specific vulnerability by ID
    async fn fetch_by_id(&self, cve_id: &str) -> Result<Option<CVE>, String>;
    
    /// Search vulnerabilities by criteria
    async fn search(&self, query: &VulnerabilityQuery) -> Result<Vec<CVE>, String>;
    
    /// Health check for the feed
    async fn health_check(&self) -> Result<HealthCheck, String>;
}

/// Vulnerability query parameters
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityQuery {
    pub keywords: Vec<String>,
    pub vendor: Option<String>,
    pub product: Option<String>,
    pub severity_min: Option<f64>,
    pub published_after: Option<DateTime<Utc>>,
    pub modified_after: Option<DateTime<Utc>>,
    pub limit: Option<usize>,
}

/// NVD (National Vulnerability Database) integration
pub struct NVDFeed {
    api_key: Option<String>,
    base_url: String,
    client: Option<reqwest::Client>,
}

impl NVDFeed {
    pub fn new(api_key: Option<String>) -> Self {
        Self {
            api_key,
            base_url: "https://services.nvd.nist.gov/rest/json".to_string(),
            client: None,
        }
    }
}

#[async_trait]
impl VulnerabilityFeed for NVDFeed {
    fn feed_name(&self) -> &'static str {
        "NVD"
    }
    
    async fn initialize(&mut self) -> Result<(), String> {
        self.client = Some(reqwest::Client::new());
        Ok(())
    }
    
    async fn fetch_recent(&self, _since: DateTime<Utc>) -> Result<Vec<CVE>, String> {
        // Implementation would fetch from NVD API
        // For now, return mock data
        Ok(vec![])
    }
    
    async fn fetch_by_id(&self, _cve_id: &str) -> Result<Option<CVE>, String> {
        // Implementation would fetch specific CVE from NVD
        Ok(None)
    }
    
    async fn search(&self, _query: &VulnerabilityQuery) -> Result<Vec<CVE>, String> {
        // Implementation would search NVD API
        Ok(vec![])
    }
    
    async fn health_check(&self) -> Result<HealthCheck, String> {
        let start_time = std::time::Instant::now();
        
        // Perform actual health check against NVD API
        let status = if self.client.is_some() {
            IntegrationStatus::Healthy
        } else {
            IntegrationStatus::Unhealthy
        };
        
        Ok(HealthCheck {
            service_name: "NVD".to_string(),
            status,
            response_time_ms: start_time.elapsed().as_millis() as u64,
            last_check: Utc::now(),
            error_message: None,
        })
    }
}

/// MITRE CVE database integration
pub struct MITREFeed {
    base_url: String,
    client: Option<reqwest::Client>,
}

impl MITREFeed {
    pub fn new() -> Self {
        Self {
            base_url: "https://cve.mitre.org".to_string(),
            client: None,
        }
    }
}

#[async_trait]
impl VulnerabilityFeed for MITREFeed {
    fn feed_name(&self) -> &'static str {
        "MITRE"
    }
    
    async fn initialize(&mut self) -> Result<(), String> {
        self.client = Some(reqwest::Client::new());
        Ok(())
    }
    
    async fn fetch_recent(&self, _since: DateTime<Utc>) -> Result<Vec<CVE>, String> {
        Ok(vec![])
    }
    
    async fn fetch_by_id(&self, _cve_id: &str) -> Result<Option<CVE>, String> {
        Ok(None)
    }
    
    async fn search(&self, _query: &VulnerabilityQuery) -> Result<Vec<CVE>, String> {
        Ok(vec![])
    }
    
    async fn health_check(&self) -> Result<HealthCheck, String> {
        let start_time = std::time::Instant::now();
        
        let status = if self.client.is_some() {
            IntegrationStatus::Healthy
        } else {
            IntegrationStatus::Unhealthy
        };
        
        Ok(HealthCheck {
            service_name: "MITRE".to_string(),
            status,
            response_time_ms: start_time.elapsed().as_millis() as u64,
            last_check: Utc::now(),
            error_message: None,
        })
    }
}

/// GitHub Security Advisories integration
pub struct GitHubSecurityFeed {
    token: Option<String>,
    client: Option<reqwest::Client>,
}

impl GitHubSecurityFeed {
    pub fn new(token: Option<String>) -> Self {
        Self {
            token,
            client: None,
        }
    }
}

#[async_trait]
impl VulnerabilityFeed for GitHubSecurityFeed {
    fn feed_name(&self) -> &'static str {
        "GitHub Security"
    }
    
    async fn initialize(&mut self) -> Result<(), String> {
        let mut builder = reqwest::ClientBuilder::new();
        if let Some(token) = &self.token {
            let mut headers = reqwest::header::HeaderMap::new();
            headers.insert(
                reqwest::header::AUTHORIZATION,
                format!("token {}", token).parse().map_err(|e| format!("Invalid token: {}", e))?
            );
            builder = builder.default_headers(headers);
        }
        self.client = Some(builder.build().map_err(|e| format!("Failed to build client: {}", e))?);
        Ok(())
    }
    
    async fn fetch_recent(&self, _since: DateTime<Utc>) -> Result<Vec<CVE>, String> {
        Ok(vec![])
    }
    
    async fn fetch_by_id(&self, _cve_id: &str) -> Result<Option<CVE>, String> {
        Ok(None)
    }
    
    async fn search(&self, _query: &VulnerabilityQuery) -> Result<Vec<CVE>, String> {
        Ok(vec![])
    }
    
    async fn health_check(&self) -> Result<HealthCheck, String> {
        let start_time = std::time::Instant::now();
        
        let status = if self.client.is_some() {
            IntegrationStatus::Healthy
        } else {
            IntegrationStatus::Unhealthy
        };
        
        Ok(HealthCheck {
            service_name: "GitHub Security".to_string(),
            status,
            response_time_ms: start_time.elapsed().as_millis() as u64,
            last_check: Utc::now(),
            error_message: None,
        })
    }
}

/// Feed manager for coordinating multiple vulnerability feeds
pub struct VulnerabilityFeedManager {
    feeds: Vec<Box<dyn VulnerabilityFeed>>,
}

impl VulnerabilityFeedManager {
    pub fn new() -> Self {
        Self {
            feeds: Vec::new(),
        }
    }
    
    pub fn add_feed(&mut self, feed: Box<dyn VulnerabilityFeed>) {
        self.feeds.push(feed);
    }
    
    pub async fn initialize_all(&mut self) -> Result<(), String> {
        for feed in &mut self.feeds {
            feed.initialize().await?;
        }
        Ok(())
    }
    
    pub async fn fetch_from_all(&self, since: DateTime<Utc>) -> Result<Vec<CVE>, String> {
        let mut all_cves = Vec::new();
        
        for feed in &self.feeds {
            match feed.fetch_recent(since).await {
                Ok(mut cves) => all_cves.append(&mut cves),
                Err(e) => {
                    eprintln!("Failed to fetch from {}: {}", feed.feed_name(), e);
                    // Continue with other feeds
                }
            }
        }
        
        // Remove duplicates based on CVE ID
        all_cves.sort_by(|a, b| a.id().cmp(b.id()));
        all_cves.dedup_by(|a, b| a.id() == b.id());
        
        Ok(all_cves)
    }
    
    pub async fn health_check_all(&self) -> Result<Vec<HealthCheck>, String> {
        let mut results = Vec::new();
        
        for feed in &self.feeds {
            match feed.health_check().await {
                Ok(check) => results.push(check),
                Err(e) => {
                    results.push(HealthCheck {
                        service_name: feed.feed_name().to_string(),
                        status: IntegrationStatus::Unhealthy,
                        response_time_ms: 0,
                        last_check: Utc::now(),
                        error_message: Some(e),
                    });
                }
            }
        }
        
        Ok(results)
    }
}

impl Default for VulnerabilityFeedManager {
    fn default() -> Self {
        Self::new()
    }
}