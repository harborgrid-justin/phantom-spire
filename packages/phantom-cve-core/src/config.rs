use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub scoring: ScoringConfig,
    pub exploit_prediction: ExploitPredictionConfig,
    pub threat_intelligence: ThreatIntelligenceConfig,
    pub actors: ActorsConfig,
    pub threat_feeds: HashMap<String, ThreatFeedConfig>,
    pub system_mapping: SystemMappingConfig,
    pub cvss_strings: CVSSStringsConfig,
    pub scoring_models: ScoringModelsConfig,
    pub recommendations: RecommendationsConfig,
    pub target_profile: TargetProfileConfig,
    pub campaigns: CampaignsConfig,
    pub remediation: RemediationConfig,
    pub database: DatabaseConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScoringConfig {
    pub critical_threshold: f64,
    pub high_threshold: f64,
    pub medium_threshold: f64,
    pub base_exploitability_weight: f64,
    pub base_impact_weight: f64,
    pub attack_vector_bonus_network: f64,
    pub attack_vector_bonus_adjacent: f64,
    pub attack_vector_bonus_local: f64,
    pub attack_vector_bonus_physical: f64,
    pub complexity_high_multiplier: f64,
    pub priv_none_bonus: f64,
    pub ui_required_multiplier: f64,
    pub age_new_threshold_days: i64,
    pub age_old_threshold_days: i64,
    pub age_new_bonus: f64,
    pub age_old_multiplier: f64,
    pub conf_high_bonus: f64,
    pub integ_high_bonus: f64,
    pub avail_high_bonus: f64,
    pub affected_per_product: f64,
    pub affected_max_bonus: f64,
    pub base_priority_multiplier: f64,
    pub exploit_factor_multiplier: f64,
    pub max_priority_score: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitPredictionConfig {
    pub prob_poc: f64,
    pub prob_weaponization: f64,
    pub prob_mass_exploitation: f64,
    pub prob_public_exploits_given_available: f64,
    pub prob_in_the_wild_given_public: f64,
    pub disclosure_lookback_days_max: u32,
    pub poc_delay_days_max: u32,
    pub weaponization_min_days: i64,
    pub weaponization_extra_days_max: u32,
    pub mass_min_days: i64,
    pub mass_extra_days_max: u32,
    pub patch_after_days: i64,
    pub severity_critical_probability: f64,
    pub severity_high_probability: f64,
    pub severity_medium_probability: f64,
    pub severity_low_probability: f64,
    pub severity_none_probability: f64,
    pub default_probability: f64,
    pub risk_progression_months: i32,
    pub risk_progression_interval_days: i32,
    pub initial_exploit_likelihood: f64,
    pub mid_exploit_likelihood: f64,
    pub late_exploit_likelihood: f64,
    pub base_impact_magnitude: f64,
    pub impact_magnitude_increment: f64,
    pub zero_day_probability: f64,
    pub basic_timeline_public_exploits_probability: f64,
    pub rng_seed: u64,
    pub lcg_multiplier: u64,
    pub lcg_increment: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatIntelligenceConfig {
    pub feed_hit_weight: f64,
    pub active_exploit_weight: f64,
    pub actor_interest_weight: f64,
    pub mock_cve_base_numbers: Vec<u32>,
    pub mock_cve_year: i32,
    pub max_mock_cve_counts: Vec<u32>,
    pub max_campaigns_per_vulnerability: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorsConfig {
    pub opportunistic: Vec<String>,
    pub apt: Vec<String>,
    pub sophisticated: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatFeedConfig {
    pub name: String,
    pub reliability: f64,
    pub feed_type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemMappingConfig {
    pub windows_systems: String,
    pub linux_systems: String,
    pub apache_systems: String,
    pub database_systems: String,
    pub email_systems: String,
    pub network_systems: String,
    pub default_systems: String,
    pub general_systems: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CVSSStringsConfig {
    pub high: String,
    pub medium: String,
    pub low: String,
    pub none: String,
    pub required: String,
    pub not_required: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScoringModelsConfig {
    pub temporal: ScoringModelConfig,
    pub environmental: ScoringModelConfig,
    pub threat: ScoringModelConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScoringModelConfig {
    pub name: String,
    pub weight: f64,
    pub factors: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecommendationsConfig {
    pub critical: Vec<String>,
    pub high: Vec<String>,
    pub medium_low: Vec<String>,
    pub general: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetProfileConfig {
    pub high_value_patterns: Vec<String>,
    pub widespread_patterns: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CampaignsConfig {
    pub by_type: HashMap<String, Vec<String>>,
    pub zero_day: Vec<String>,
    pub supply_chain: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemediationConfig {
    pub critical_threshold: f64,
    pub high_threshold: f64,
    pub medium_threshold: f64,
    pub immediate_mitigations: HashMap<String, Vec<String>>,
    pub compensating_controls: HashMap<String, Vec<CompensatingControlConfig>>,
    pub remediation_templates: HashMap<String, Vec<RemediationTemplateConfig>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompensatingControlConfig {
    pub control_type: String,
    pub description: String,
    pub effectiveness: f64,
    pub implementation_cost: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemediationTemplateConfig {
    pub vulnerability_pattern: String,
    pub actions: Vec<RemediationActionConfig>,
    pub success_rate: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemediationActionConfig {
    pub action_type: String,
    pub description: String,
    pub estimated_time: String,
    pub resources_required: Vec<String>,
    pub dependencies: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseConfig {
    pub db_type: DatabaseType,
    pub local: LocalStorageConfig,
    pub postgres: PostgresConfig,
    pub elasticsearch: ElasticsearchConfig,
    pub mongodb: MongoDbConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DatabaseType {
    Local,
    Postgres,
    Elasticsearch,
    MongoDB,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocalStorageConfig {
    pub data_directory: String,
    pub file_format: String, // json, toml, etc.
    pub max_file_size_mb: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PostgresConfig {
    pub host: String,
    pub port: u16,
    pub database: String,
    pub username: String,
    pub password: String,
    pub ssl_mode: String,
    pub connection_pool_size: u32,
    pub timeout_seconds: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ElasticsearchConfig {
    pub hosts: Vec<String>,
    pub index_prefix: String,
    pub username: Option<String>,
    pub password: Option<String>,
    pub timeout_seconds: u64,
    pub max_retries: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MongoDbConfig {
    pub connection_string: String,
    pub database: String,
    pub collection_prefix: String,
    pub timeout_seconds: u64,
    pub max_pool_size: u32,
}

impl Config {
    /// Load configuration from a TOML file
    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self, ConfigError> {
        let content = fs::read_to_string(&path)
            .map_err(|e| ConfigError::FileRead {
                path: path.as_ref().to_string_lossy().to_string(),
                error: e.to_string(),
            })?;
        
        Self::load_from_string(&content)
    }

    /// Load configuration from a TOML string
    pub fn load_from_string(content: &str) -> Result<Self, ConfigError> {
        toml::from_str(content)
            .map_err(|e| ConfigError::ParseError(e.to_string()))
    }

    /// Load configuration with fallback to default if file doesn't exist
    pub fn load_with_default<P: AsRef<Path>>(path: P) -> Self {
        match Self::load_from_file(&path) {
            Ok(config) => config,
            Err(ConfigError::FileRead { .. }) => {
                eprintln!("Warning: Configuration file not found at {}, using defaults", 
                         path.as_ref().to_string_lossy());
                Self::default()
            }
            Err(e) => {
                eprintln!("Warning: Failed to parse configuration file: {}, using defaults", e);
                Self::default()
            }
        }
    }
}

impl Default for Config {
    fn default() -> Self {
        // Default configuration matching the original hardcoded values
        Self {
            scoring: ScoringConfig {
                critical_threshold: 9.0,
                high_threshold: 7.0,
                medium_threshold: 4.0,
                base_exploitability_weight: 0.4,
                base_impact_weight: 0.6,
                attack_vector_bonus_network: 0.3,
                attack_vector_bonus_adjacent: 0.2,
                attack_vector_bonus_local: 0.1,
                attack_vector_bonus_physical: 0.05,
                complexity_high_multiplier: 0.8,
                priv_none_bonus: 0.2,
                ui_required_multiplier: 0.7,
                age_new_threshold_days: 30,
                age_old_threshold_days: 365,
                age_new_bonus: 0.1,
                age_old_multiplier: 0.9,
                conf_high_bonus: 0.2,
                integ_high_bonus: 0.15,
                avail_high_bonus: 0.15,
                affected_per_product: 0.05,
                affected_max_bonus: 0.2,
                base_priority_multiplier: 10.0,
                exploit_factor_multiplier: 50.0,
                max_priority_score: 100,
            },
            exploit_prediction: ExploitPredictionConfig {
                prob_poc: 0.70,
                prob_weaponization: 0.50,
                prob_mass_exploitation: 0.30,
                prob_public_exploits_given_available: 0.60,
                prob_in_the_wild_given_public: 0.40,
                disclosure_lookback_days_max: 365,
                poc_delay_days_max: 30,
                weaponization_min_days: 30,
                weaponization_extra_days_max: 90,
                mass_min_days: 60,
                mass_extra_days_max: 180,
                patch_after_days: 30,
                severity_critical_probability: 0.8,
                severity_high_probability: 0.6,
                severity_medium_probability: 0.3,
                severity_low_probability: 0.1,
                severity_none_probability: 0.05,
                default_probability: 0.2,
                risk_progression_months: 10,
                risk_progression_interval_days: 30,
                initial_exploit_likelihood: 0.1,
                mid_exploit_likelihood: 0.4,
                late_exploit_likelihood: 0.8,
                base_impact_magnitude: 0.5,
                impact_magnitude_increment: 0.05,
                zero_day_probability: 0.10,
                basic_timeline_public_exploits_probability: 0.40,
                rng_seed: 98765,
                lcg_multiplier: 1664525,
                lcg_increment: 1013904223,
            },
            threat_intelligence: ThreatIntelligenceConfig {
                feed_hit_weight: 0.1,
                active_exploit_weight: 0.3,
                actor_interest_weight: 0.2,
                mock_cve_base_numbers: vec![10000, 20000, 30000],
                mock_cve_year: 2024,
                max_mock_cve_counts: vec![5, 3, 4],
                max_campaigns_per_vulnerability: 3,
            },
            actors: ActorsConfig {
                opportunistic: vec![
                    "Script Kiddies".to_string(),
                    "Cyber Criminal Groups".to_string(),
                    "Hacktivists".to_string(),
                ],
                apt: vec![
                    "APT29".to_string(),
                    "APT41".to_string(),
                    "Lazarus Group".to_string(),
                    "Sandworm".to_string(),
                ],
                sophisticated: vec![
                    "APT28".to_string(),
                    "APT29".to_string(),
                    "Equation Group".to_string(),
                    "FIN7".to_string(),
                ],
            },
            threat_feeds: {
                let mut feeds = HashMap::new();
                feeds.insert("alienvault_otx".to_string(), ThreatFeedConfig {
                    name: "AlienVault OTX".to_string(),
                    reliability: 0.9,
                    feed_type: "open_source".to_string(),
                });
                feeds.insert("abuseipdb".to_string(), ThreatFeedConfig {
                    name: "AbuseIPDB".to_string(),
                    reliability: 0.8,
                    feed_type: "reputation".to_string(),
                });
                feeds.insert("threatstream".to_string(), ThreatFeedConfig {
                    name: "Anomali ThreatStream".to_string(),
                    reliability: 0.95,
                    feed_type: "commercial".to_string(),
                });
                feeds
            },
            system_mapping: SystemMappingConfig {
                windows_systems: "Windows Servers".to_string(),
                linux_systems: "Linux Servers".to_string(),
                apache_systems: "Web Servers".to_string(),
                database_systems: "Database Servers".to_string(),
                email_systems: "Email Servers".to_string(),
                network_systems: "Network Infrastructure".to_string(),
                default_systems: "Application Servers".to_string(),
                general_systems: "General Systems".to_string(),
            },
            cvss_strings: CVSSStringsConfig {
                high: "High".to_string(),
                medium: "Medium".to_string(),
                low: "Low".to_string(),
                none: "None".to_string(),
                required: "Required".to_string(),
                not_required: "Not Required".to_string(),
            },
            scoring_models: ScoringModelsConfig {
                temporal: ScoringModelConfig {
                    name: "temporal_scoring".to_string(),
                    weight: 0.3,
                    factors: vec!["age".to_string(), "patch_availability".to_string()],
                },
                environmental: ScoringModelConfig {
                    name: "environmental_scoring".to_string(),
                    weight: 0.4,
                    factors: vec!["asset_value".to_string(), "exposure".to_string()],
                },
                threat: ScoringModelConfig {
                    name: "threat_scoring".to_string(),
                    weight: 0.3,
                    factors: vec!["actor_interest".to_string(), "exploit_maturity".to_string()],
                },
            },
            recommendations: RecommendationsConfig {
                critical: vec![
                    "CRITICAL: Apply emergency patches immediately".to_string(),
                    "Implement temporary workarounds if patches unavailable".to_string(),
                    "Consider system isolation until patched".to_string(),
                ],
                high: vec![
                    "Apply vendor patches within 24-48 hours".to_string(),
                    "Increase monitoring for exploitation attempts".to_string(),
                ],
                medium_low: vec![
                    "Apply patches during next maintenance window".to_string(),
                    "Review and update security configurations".to_string(),
                ],
                general: vec![
                    "Implement defense-in-depth measures".to_string(),
                    "Update threat hunting signatures".to_string(),
                    "Brief security team on new threat vectors".to_string(),
                ],
            },
            target_profile: TargetProfileConfig {
                high_value_patterns: vec![
                    "windows".to_string(),
                    "office".to_string(),
                    "exchange".to_string(),
                    "sharepoint".to_string(),
                ],
                widespread_patterns: vec![
                    "windows".to_string(),
                    "office".to_string(),
                    "apache".to_string(),
                    "nginx".to_string(),
                ],
            },
            campaigns: CampaignsConfig {
                by_type: {
                    let mut campaigns = HashMap::new();
                    campaigns.insert("rce".to_string(), vec![
                        "Operation Shadowhammer".to_string(),
                        "SolarWinds Campaign".to_string(),
                    ]);
                    campaigns.insert("privilege_escalation".to_string(), vec![
                        "DarkHalo".to_string(),
                        "UNC2452".to_string(),
                    ]);
                    campaigns.insert("information_disclosure".to_string(), vec![
                        "APT29 Intelligence".to_string(),
                        "Cozy Bear Data Theft".to_string(),
                    ]);
                    campaigns.insert("default".to_string(), vec![
                        "Generic Threat Campaign".to_string(),
                    ]);
                    campaigns
                },
                zero_day: vec![
                    "Operation Aurora".to_string(),
                    "Stuxnet Campaign".to_string(),
                    "APT Advanced Operations".to_string(),
                ],
                supply_chain: vec![
                    "SolarWinds Orion".to_string(),
                    "CCleaner Supply Chain".to_string(),
                    "NotPetya Distribution".to_string(),
                ],
            },
            remediation: RemediationConfig {
                critical_threshold: 9.0,
                high_threshold: 7.0,
                medium_threshold: 4.0,
                immediate_mitigations: {
                    let mut mitigations = HashMap::new();
                    mitigations.insert("remote_code_execution".to_string(), vec![
                        "Block vulnerable service ports".to_string(),
                        "Implement rate limiting".to_string(),
                        "Enable enhanced logging".to_string(),
                    ]);
                    mitigations.insert("sql_injection".to_string(), vec![
                        "Enable WAF SQL injection rules".to_string(),
                        "Implement input validation".to_string(),
                        "Use prepared statements".to_string(),
                    ]);
                    mitigations.insert("xss".to_string(), vec![
                        "Enable Content Security Policy".to_string(),
                        "Implement output encoding".to_string(),
                        "Enable WAF XSS protection".to_string(),
                    ]);
                    mitigations.insert("default".to_string(), vec![
                        "Implement general hardening measures".to_string(),
                        "Enable security monitoring".to_string(),
                        "Review access controls".to_string(),
                    ]);
                    mitigations
                },
                compensating_controls: {
                    let mut controls = HashMap::new();
                    controls.insert("remote_code_execution".to_string(), vec![
                        CompensatingControlConfig {
                            control_type: "network_segmentation".to_string(),
                            description: "Implement network segmentation to limit lateral movement".to_string(),
                            effectiveness: 0.8,
                            implementation_cost: "Medium".to_string(),
                        },
                        CompensatingControlConfig {
                            control_type: "intrusion_detection".to_string(),
                            description: "Deploy intrusion detection systems".to_string(),
                            effectiveness: 0.7,
                            implementation_cost: "High".to_string(),
                        },
                    ]);
                    controls.insert("sql_injection".to_string(), vec![
                        CompensatingControlConfig {
                            control_type: "database_firewall".to_string(),
                            description: "Implement database firewall".to_string(),
                            effectiveness: 0.9,
                            implementation_cost: "Medium".to_string(),
                        },
                        CompensatingControlConfig {
                            control_type: "input_validation".to_string(),
                            description: "Enhanced input validation at application layer".to_string(),
                            effectiveness: 0.85,
                            implementation_cost: "Low".to_string(),
                        },
                    ]);
                    controls.insert("default".to_string(), vec![
                        CompensatingControlConfig {
                            control_type: "monitoring".to_string(),
                            description: "Enhanced security monitoring and alerting".to_string(),
                            effectiveness: 0.6,
                            implementation_cost: "Low".to_string(),
                        },
                    ]);
                    controls
                },
                remediation_templates: {
                    let mut templates = HashMap::new();
                    templates.insert("remote_code_execution".to_string(), vec![
                        RemediationTemplateConfig {
                            vulnerability_pattern: "remote_code_execution".to_string(),
                            actions: vec![
                                RemediationActionConfig {
                                    action_type: "patch".to_string(),
                                    description: "Apply vendor security patch".to_string(),
                                    estimated_time: "2-4 hours".to_string(),
                                    resources_required: vec!["System Administrator".to_string()],
                                    dependencies: vec![],
                                },
                                RemediationActionConfig {
                                    action_type: "network".to_string(),
                                    description: "Implement network segmentation".to_string(),
                                    estimated_time: "4-8 hours".to_string(),
                                    resources_required: vec!["Network Engineer".to_string()],
                                    dependencies: vec![],
                                },
                            ],
                            success_rate: 0.95,
                        },
                    ]);
                    templates.insert("sql_injection".to_string(), vec![
                        RemediationTemplateConfig {
                            vulnerability_pattern: "sql_injection".to_string(),
                            actions: vec![
                                RemediationActionConfig {
                                    action_type: "code".to_string(),
                                    description: "Implement parameterized queries".to_string(),
                                    estimated_time: "8-16 hours".to_string(),
                                    resources_required: vec!["Developer".to_string()],
                                    dependencies: vec![],
                                },
                                RemediationActionConfig {
                                    action_type: "waf".to_string(),
                                    description: "Deploy Web Application Firewall".to_string(),
                                    estimated_time: "2-4 hours".to_string(),
                                    resources_required: vec!["Security Engineer".to_string()],
                                    dependencies: vec![],
                                },
                            ],
                            success_rate: 0.90,
                        },
                    ]);
                    templates
                },
            },
            database: DatabaseConfig {
                db_type: DatabaseType::Local,
                local: LocalStorageConfig {
                    data_directory: "./data".to_string(),
                    file_format: "json".to_string(),
                    max_file_size_mb: 100,
                },
                postgres: PostgresConfig {
                    host: "localhost".to_string(),
                    port: 5432,
                    database: "phantom_cve".to_string(),
                    username: "phantom".to_string(),
                    password: "password".to_string(),
                    ssl_mode: "prefer".to_string(),
                    connection_pool_size: 10,
                    timeout_seconds: 30,
                },
                elasticsearch: ElasticsearchConfig {
                    hosts: vec!["http://localhost:9200".to_string()],
                    index_prefix: "phantom_cve".to_string(),
                    username: None,
                    password: None,
                    timeout_seconds: 30,
                    max_retries: 3,
                },
                mongodb: MongoDbConfig {
                    connection_string: "mongodb://localhost:27017".to_string(),
                    database: "phantom_cve".to_string(),
                    collection_prefix: "cve".to_string(),
                    timeout_seconds: 30,
                    max_pool_size: 10,
                },
            },
        }
    }
}

#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    #[error("Failed to read config file '{path}': {error}")]
    FileRead { path: String, error: String },
    
    #[error("Failed to parse config file: {0}")]
    ParseError(String),
}