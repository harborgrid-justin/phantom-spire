// CVE Core implementation with N-API native addon and fallback

import {
  CVE,
  CVEAnalysisResult,
  VulnerabilityAssessment,
  CVESearchCriteria,
  ExploitTimeline,
  RemediationStrategy
} from './types';

// Try to import native addon, fallback to mock implementation
let CVECoreNapi: any = null;
let useNativeAddon = false;

try {
  // Use dynamic import for native addon
  const nativeModule = require('../index');
  CVECoreNapi = nativeModule.CVECoreNapi;
  useNativeAddon = true;
} catch (error) {
  console.warn('Native addon not available, using mock implementation');
  useNativeAddon = false;
}

export class CVECore {
  private nativeCore: any;
  private threatFeeds: string[] = [
    'alienvault_otx',
    'abuseipdb',
    'anomali_threatstream',
    'mandiant',
    'crowdstrike_intelligence'
  ];

  private constructor(nativeCore?: any) {
    this.nativeCore = nativeCore;
  }

  // Static constructor to align with README usage
  static async new(): Promise<CVECore> {
    if (useNativeAddon && CVECoreNapi) {
      try {
        const nativeCore = new CVECoreNapi();
        return new CVECore(nativeCore);
      } catch (error) {
        console.warn('Failed to initialize native addon, falling back to mock:', error);
        return new CVECore();
      }
    }
    return new CVECore();
  }

  async process_cve(cve: CVE): Promise<CVEAnalysisResult> {
    if (this.nativeCore) {
      try {
        const cveJson = JSON.stringify(cve);
        const resultJson = this.nativeCore.process_cve(cveJson);
        return JSON.parse(resultJson);
      } catch (error) {
        console.warn('Native addon failed, using fallback:', error);
        return this.process_cve_fallback(cve);
      }
    }
    return this.process_cve_fallback(cve);
  }

  async batch_process_cves(cves: CVE[]): Promise<CVEAnalysisResult[]> {
    if (this.nativeCore) {
      try {
        const cvesJson = JSON.stringify(cves);
        const resultsJson = this.nativeCore.batch_process_cves(cvesJson);
        return JSON.parse(resultsJson);
      } catch (error) {
        console.warn('Native addon failed, using fallback:', error);
        return this.batch_process_cves_fallback(cves);
      }
    }
    return this.batch_process_cves_fallback(cves);
  }

  // Alias to align with README naming
  async process_cves_batch(cves: CVE[]): Promise<CVEAnalysisResult[]> {
    return this.batch_process_cves(cves);
  }

  async get_exploit_timeline(cve_id: string): Promise<ExploitTimeline> {
    if (this.nativeCore) {
      try {
        const timelineJson = this.nativeCore.get_exploit_timeline(cve_id);
        return JSON.parse(timelineJson);
      } catch (error) {
        console.warn('Native addon failed, using fallback:', error);
        return this.get_exploit_timeline_fallback(cve_id);
      }
    }
    return this.get_exploit_timeline_fallback(cve_id);
  }

  async get_remediation_strategy(cve: CVE): Promise<RemediationStrategy> {
    if (this.nativeCore) {
      try {
        const cveJson = JSON.stringify(cve);
        const strategyJson = this.nativeCore.get_remediation_strategy(cveJson);
        return JSON.parse(strategyJson);
      } catch (error) {
        console.warn('Native addon failed, using fallback:', error);
        return this.get_remediation_strategy_fallback(cve);
      }
    }
    return this.get_remediation_strategy_fallback(cve);
  }

  async search_cves(criteria: CVESearchCriteria): Promise<CVE[]> {
    if (this.nativeCore) {
      try {
        const criteriaJson = JSON.stringify(criteria);
        const resultsJson = this.nativeCore.search_vulnerabilities(criteriaJson);
        return JSON.parse(resultsJson);
      } catch (error) {
        console.warn('Native addon failed, using fallback:', error);
        return this.search_cves_fallback(criteria);
      }
    }
    return this.search_cves_fallback(criteria);
  }

  // Health status endpoint for operational checks
  async get_health_status(): Promise<{ status: string; timestamp: Date; version: string }> {
    if (this.nativeCore) {
      try {
        const healthJson = this.nativeCore.get_health_status();
        const health = JSON.parse(healthJson);
        return {
          ...health,
          timestamp: new Date(health.timestamp)
        };
      } catch (error) {
        console.warn('Native addon failed, using fallback:', error);
        return this.get_health_status_fallback();
      }
    }
    return this.get_health_status_fallback();
  }

  // Fallback implementations
  private async process_cve_fallback(cve: CVE): Promise<CVEAnalysisResult> {
    const assessment = this.generate_assessment(cve);
    const related_cves = this.find_related_cves(cve);
    const threat_actors = this.correlate_threat_actors(cve);
    const campaigns = this.map_to_campaigns(cve);

    return {
      cve,
      assessment,
      processing_timestamp: new Date(),
      related_cves,
      threat_actors,
      campaigns
    };
  }

  private async batch_process_cves_fallback(cves: CVE[]): Promise<CVEAnalysisResult[]> {
    const results: CVEAnalysisResult[] = [];
    for (const cve of cves) {
      results.push(await this.process_cve_fallback(cve));
    }
    return results;
  }

  private async get_exploit_timeline_fallback(cve_id: string): Promise<ExploitTimeline> {
    const disclosure_date = new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000);
    const exploitation_stages = [];
    const risk_progression = [];

    exploitation_stages.push({
      stage: "Disclosure",
      date: disclosure_date,
      description: "Vulnerability publicly disclosed",
      threat_actors: [],
      tools_used: []
    });

    if (Math.random() > 0.3) {
      const poc_date = new Date(disclosure_date.getTime() + Math.random() * 30 * 24 * 60 * 60 * 1000);
      exploitation_stages.push({
        stage: "Proof of Concept",
        date: poc_date,
        description: "Proof of concept exploit released",
        threat_actors: ["Security Researchers"],
        tools_used: ["Custom PoC"]
      });
    }

    for (let i = 0; i < 10; i++) {
      const date = new Date(disclosure_date.getTime() + i * 30 * 24 * 60 * 60 * 1000);
      const risk_score = Math.min(1, i * 0.1);
      const exploitation_likelihood = i < 3 ? 0.1 : i < 6 ? 0.4 : 0.8;
      const impact_magnitude = 0.5 + i * 0.05;

      risk_progression.push({
        date,
        risk_score,
        exploitation_likelihood,
        impact_magnitude
      });
    }

    return {
      cve_id,
      disclosure_date,
      first_exploit_date: exploitation_stages[1]?.date,
      weaponization_date: exploitation_stages[2]?.date,
      mass_exploitation_date: exploitation_stages[3]?.date,
      patch_available_date: new Date(disclosure_date.getTime() + 30 * 24 * 60 * 60 * 1000),
      exploitation_stages,
      risk_progression
    };
  }

  private async get_remediation_strategy_fallback(cve: CVE): Promise<RemediationStrategy> {
    const base_score = cve.cvss_metrics?.base_score || 5.0;
    const priority = base_score >= 9.0 ? 'critical' :
                    base_score >= 7.0 ? 'high' :
                    base_score >= 4.0 ? 'medium' : 'low';

    const vuln_type = this.classify_vulnerability_type(cve);
    const immediate_actions = this.generate_immediate_actions(vuln_type, priority);
    const short_term_actions = this.generate_short_term_actions(vuln_type);

    const total_hours = immediate_actions.reduce((sum, action) => {
      const hours = action.estimated_time.includes('2-4') ? 3 :
                   action.estimated_time.includes('4-8') ? 6 :
                   action.estimated_time.includes('8-16') ? 12 : 4;
      return sum + hours;
    }, 0);

    return {
      cve_id: cve.id,
      priority: priority as any,
      immediate_actions,
      short_term_actions,
      long_term_actions: [],
      compensating_controls: this.generate_compensating_controls(vuln_type),
      estimated_effort: {
        hours: total_hours,
        complexity: total_hours > 40 ? 'High' : total_hours > 16 ? 'Medium' : 'Low',
        skills_required: ['System Administrator', 'Security Engineer']
      }
    };
  }

  private async search_cves_fallback(criteria: CVESearchCriteria): Promise<CVE[]> {
    const base: CVE[] = Array.from({ length: 8 }).map((_, i) =>
      this.make_mock_cve(`CVE-2024-${(10000 + i).toString().padStart(4, '0')}`, 5 + Math.random() * 4)
    );

    return base.filter(cve => {
      if (criteria.cve_id && cve.id !== criteria.cve_id) return false;
      if (criteria.vendor && !cve.affected_products.some(p => p.vendor.toLowerCase().includes(criteria.vendor!.toLowerCase()))) return false;
      if (criteria.product && !cve.affected_products.some(p => p.product.toLowerCase().includes(criteria.product!.toLowerCase()))) return false;
      if (criteria.min_score && (cve.cvss_metrics?.base_score ?? 0) < criteria.min_score) return false;
      if (criteria.max_score && (cve.cvss_metrics?.base_score ?? 10) > criteria.max_score) return false;
      if (criteria.severity && cve.cvss_metrics?.severity !== criteria.severity) return false;
      return true;
    });
  }

  private get_health_status_fallback(): { status: string; timestamp: Date; version: string } {
    return {
      status: 'ok (mock)',
      timestamp: new Date(),
      version: '0.1.0'
    };
  }

  // Helper methods for fallback implementation
  private classify_vulnerability_type(cve: CVE): string {
    const desc = cve.description.toLowerCase();
    if (desc.includes('remote code execution') || desc.includes('rce')) return 'remote_code_execution';
    if (desc.includes('sql injection')) return 'sql_injection';
    if (desc.includes('cross-site scripting') || desc.includes('xss')) return 'xss';
    return 'general';
  }

  private generate_immediate_actions(vuln_type: string, priority: string): any[] {
    const actions = [];
    if (priority === 'critical') {
      actions.push({
        action_type: 'patch',
        description: 'Apply emergency security patch immediately',
        estimated_time: '2-4 hours',
        resources_required: ['System Administrator'],
        dependencies: []
      });
    }
    return actions;
  }

  private generate_short_term_actions(vuln_type: string): any[] {
    return [];
  }

  private generate_compensating_controls(vuln_type: string): any[] {
    return [{
      control_type: 'monitoring',
      description: 'Enhanced security monitoring and alerting',
      effectiveness: 0.6,
      implementation_cost: 'Low'
    }];
  }

  private generate_assessment(cve: CVE): VulnerabilityAssessment {
    const base_score = cve.cvss_metrics?.base_score || 5.0;
    const exploitability = this.calculate_exploitability(cve);
    const impact_score = base_score * 0.6;

    let risk_level: 'low' | 'medium' | 'high' | 'critical' = 'low';
    if (base_score >= 9.0) risk_level = 'critical';
    else if (base_score >= 7.0) risk_level = 'high';
    else if (base_score >= 4.0) risk_level = 'medium';

    return {
      exploitability,
      impact_score,
      risk_level,
      affected_systems: this.identify_affected_systems(cve),
      remediation_priority: Math.floor(base_score * 10),
      exploit_available: Math.random() > 0.6,
      public_exploits: Math.random() > 0.7,
      in_the_wild: Math.random() > 0.8,
      recommendations: this.generate_recommendations(cve),
      mitigation_steps: this.generate_mitigation_steps(cve)
    };
  }

  private find_related_cves(cve: CVE): string[] {
    const hash = Array.from(cve.id).reduce((acc, ch) => acc + ch.charCodeAt(0), 0);
    const count = (hash % 5) + 1;
    return Array.from({ length: count }).map((_, i) =>
      `CVE-2024-${(20000 + i).toString().padStart(4, '0')}`
    );
  }

  private correlate_threat_actors(cve: CVE): string[] {
    const base_score = cve.cvss_metrics?.base_score || 5.0;
    if (base_score >= 8.0) return ['APT Groups', 'Nation-State Actors'];
    if (base_score >= 6.0) return ['Cyber Criminal Organizations', 'Hacktivists'];
    return ['Script Kiddies', 'Opportunistic Attackers'];
  }

  private map_to_campaigns(cve: CVE): string[] {
    const vuln_type = this.classify_vulnerability_type(cve);
    switch (vuln_type) {
      case 'remote_code_execution': return ['RCE Exploitation Campaigns', 'Zero-Day Operations'];
      case 'sql_injection': return ['Web Application Attacks', 'Data Breach Campaigns'];
      default: return ['Generic Exploitation', 'Supply Chain Attacks'];
    }
  }

  private calculate_exploitability(cve: CVE): number {
    const base_score = cve.cvss_metrics?.base_score || 5.0;
    const age_days = (Date.now() - cve.published_date.getTime()) / (1000 * 60 * 60 * 24);
    let exploitability = base_score * 0.1;
    if (age_days < 30) exploitability += 0.2;
    return Math.max(0, Math.min(1, exploitability));
  }

  private identify_affected_systems(cve: CVE): string[] {
    return ['Application Servers', 'Web Servers'];
  }

  private generate_recommendations(cve: CVE): string[] {
    const base_score = cve.cvss_metrics?.base_score || 5.0;
    if (base_score >= 9.0) return ['CRITICAL: Apply patches immediately', 'Isolate affected systems'];
    if (base_score >= 7.0) return ['Apply patches within 24-48 hours', 'Increase security monitoring'];
    return ['Schedule patch deployment', 'Review security configurations'];
  }

  private generate_mitigation_steps(cve: CVE): string[] {
    const vuln_type = this.classify_vulnerability_type(cve);
    switch (vuln_type) {
      case 'remote_code_execution': return ['Block vulnerable ports', 'Implement network segmentation'];
      case 'sql_injection': return ['Enable WAF protection', 'Implement input validation'];
      default: return ['Apply vendor patches', 'Update security configurations'];
    }
  }

  private make_mock_cve(id: string, score: number): CVE {
    return {
      id,
      description: `Mock vulnerability ${id}`,
      published_date: new Date(Date.now() - Math.floor(Math.random() * 60) * 86400000),
      last_modified_date: new Date(),
      status: 'published',
      assigner: 'cve@mitre.org',
      tags: ['mock'],
      affected_products: [{
        vendor: 'Mock Vendor',
        product: 'Mock Product',
        version: '1.0.0'
      }],
      references: [{ url: `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${id}`, source: 'MITRE', tags: ['vendor-advisory'] }],
      cvss_metrics: {
        version: '3.1' as any,
        base_score: score,
        severity: score >= 9 ? 'critical' as any : score >= 7 ? 'high' as any : score >= 4 ? 'medium' as any : 'low' as any,
        attack_vector: 'network' as any,
        attack_complexity: 'low' as any,
        privileges_required: 'none' as any,
        user_interaction: 'none' as any,
        scope: 'unchanged' as any,
        confidentiality_impact: 'high' as any,
        integrity_impact: 'high' as any,
        availability_impact: 'high' as any
      }
    };
  }
}

// Export types for convenience
export * from './types';
