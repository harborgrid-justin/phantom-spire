// Vulnerability Management Engine
use async_trait::async_trait;
use dashmap::DashMap;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityRecord {
    pub vulnerability_id: String,
    pub cve_id: Option<String>,
    pub title: String,
    pub description: String,
    pub severity: String,
    pub cvss_score: f64,
    pub affected_assets: Vec<String>,
    pub patch_available: bool,
    pub remediation_steps: Vec<String>,
    pub discovered_at: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanConfiguration {
    pub scan_id: String,
    pub scan_name: String,
    pub target_assets: Vec<String>,
    pub scan_type: String,
    pub schedule: Option<String>,
    pub enabled: bool,
}

#[async_trait]
pub trait VulnerabilityManagementTrait {
    async fn create_scan(&self, config: ScanConfiguration) -> Result<String, String>;
    async fn run_scan(&self, scan_id: &str) -> Result<Vec<VulnerabilityRecord>, String>;
    async fn prioritize_vulnerabilities(&self) -> Vec<VulnerabilityRecord>;
    async fn track_remediation(&self, vulnerability_id: &str, status: &str) -> Result<(), String>;
    async fn get_vulnerability_status(&self) -> String;
}

#[derive(Clone)]
pub struct VulnerabilityManagementEngine {
    scan_configs: Arc<DashMap<String, ScanConfiguration>>,
    vulnerabilities: Arc<DashMap<String, VulnerabilityRecord>>,
    completed_scans: Arc<RwLock<u64>>,
    active_vulnerabilities: Arc<RwLock<u64>>,
    remediated_vulnerabilities: Arc<RwLock<u64>>,
    last_error: Arc<RwLock<Option<String>>>,
}

impl VulnerabilityManagementEngine {
    pub fn new() -> Self {
        Self {
            scan_configs: Arc::new(DashMap::new()),
            vulnerabilities: Arc::new(DashMap::new()),
            completed_scans: Arc::new(RwLock::new(0)),
            active_vulnerabilities: Arc::new(RwLock::new(0)),
            remediated_vulnerabilities: Arc::new(RwLock::new(0)),
            last_error: Arc::new(RwLock::new(None)),
        }
    }
}

#[async_trait]
impl VulnerabilityManagementTrait for VulnerabilityManagementEngine {
    async fn create_scan(&self, config: ScanConfiguration) -> Result<String, String> {
        let scan_id = config.scan_id.clone();
        self.scan_configs.insert(scan_id.clone(), config);
        Ok(scan_id)
    }

    async fn run_scan(&self, _scan_id: &str) -> Result<Vec<VulnerabilityRecord>, String> {
        let mut completed = self.completed_scans.write().await;
        *completed += 1;
        
        let vulnerability = VulnerabilityRecord {
            vulnerability_id: format!("vuln_{}", chrono::Utc::now().timestamp()),
            cve_id: Some("CVE-2023-12345".to_string()),
            title: "SQL Injection Vulnerability".to_string(),
            description: "Application vulnerable to SQL injection attacks".to_string(),
            severity: "high".to_string(),
            cvss_score: 8.5,
            affected_assets: vec!["web-server-01".to_string()],
            patch_available: true,
            remediation_steps: vec!["Update application to latest version".to_string()],
            discovered_at: chrono::Utc::now().timestamp(),
        };
        
        self.vulnerabilities.insert(vulnerability.vulnerability_id.clone(), vulnerability.clone());
        
        let mut active = self.active_vulnerabilities.write().await;
        *active += 1;
        
        Ok(vec![vulnerability])
    }

    async fn prioritize_vulnerabilities(&self) -> Vec<VulnerabilityRecord> {
        let mut vulns: Vec<VulnerabilityRecord> = self.vulnerabilities
            .iter()
            .map(|entry| entry.value().clone())
            .collect();
        
        vulns.sort_by(|a, b| b.cvss_score.partial_cmp(&a.cvss_score).unwrap());
        vulns
    }

    async fn track_remediation(&self, vulnerability_id: &str, status: &str) -> Result<(), String> {
        if status == "remediated" {
            if self.vulnerabilities.contains_key(vulnerability_id) {
                self.vulnerabilities.remove(vulnerability_id);
                let mut remediated = self.remediated_vulnerabilities.write().await;
                *remediated += 1;
                let mut active = self.active_vulnerabilities.write().await;
                if *active > 0 {
                    *active -= 1;
                }
            }
        }
        Ok(())
    }

    async fn get_vulnerability_status(&self) -> String {
        let completed = *self.completed_scans.read().await;
        let active = *self.active_vulnerabilities.read().await;
        let remediated = *self.remediated_vulnerabilities.read().await;
        format!("Vulnerability Management Engine: {} scans completed, {} active vulnerabilities, {} remediated", 
               completed, active, remediated)
    }
}