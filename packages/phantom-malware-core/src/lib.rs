// phantom-malware-core/src/lib.rs
// Advanced malware analysis and threat detection library with N-API bindings

use napi::bindgen_prelude::*;
use napi_derive::napi;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use uuid::Uuid;
use sha2::{Sha256, Digest};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareSignature {
    pub id: String,
    pub name: String,
    pub signature_type: SignatureType,
    pub pattern: String,
    pub family: String,
    pub severity: MalwareSeverity,
    pub detection_confidence: f64,
    pub created_date: DateTime<Utc>,
    pub last_updated: DateTime<Utc>,
    pub author: String,
    pub tags: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SignatureType {
    Hash,
    YARA,
    Pattern,
    Behavioral,
    Network,
    Registry,
    FileSystem,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MalwareSeverity {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareAnalysisResult {
    pub file_hash: String,
    pub detected: bool,
    pub malware_family: Option<String>,
    pub confidence_score: f64,
    pub threat_level: MalwareSeverity,
    pub matched_signatures: Vec<String>,
    pub behavioral_indicators: Vec<BehavioralIndicator>,
    pub network_indicators: Vec<NetworkIndicator>,
    pub file_indicators: Vec<FileIndicator>,
    pub analysis_timestamp: DateTime<Utc>,
    pub sandbox_report: Option<SandboxReport>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BehavioralIndicator {
    pub behavior_type: String,
    pub description: String,
    pub severity: MalwareSeverity,
    pub confidence: f64,
    pub mitre_technique: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkIndicator {
    pub indicator_type: String,
    pub value: String,
    pub direction: String,
    pub protocol: String,
    pub port: Option<u16>,
    pub reputation_score: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileIndicator {
    pub file_path: String,
    pub file_hash: String,
    pub file_size: u64,
    pub file_type: String,
    pub modification_time: DateTime<Utc>,
    pub is_suspicious: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxReport {
    pub execution_time: u64,
    pub processes_created: Vec<String>,
    pub files_modified: Vec<String>,
    pub network_connections: Vec<String>,
    pub registry_changes: Vec<String>,
    pub api_calls: Vec<String>,
    pub overall_score: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatIntelligence {
    pub family_info: HashMap<String, MalwareFamily>,
    pub campaign_data: HashMap<String, ThreatCampaign>,
    pub actor_profiles: HashMap<String, ThreatActor>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareFamily {
    pub name: String,
    pub aliases: Vec<String>,
    pub first_seen: DateTime<Utc>,
    pub last_seen: DateTime<Utc>,
    pub description: String,
    pub capabilities: Vec<String>,
    pub associated_actors: Vec<String>,
    pub targeted_industries: Vec<String>,
    pub propagation_methods: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatCampaign {
    pub id: String,
    pub name: String,
    pub start_date: DateTime<Utc>,
    pub end_date: Option<DateTime<Utc>>,
    pub malware_families: Vec<String>,
    pub targeted_regions: Vec<String>,
    pub attack_vectors: Vec<String>,
    pub attribution: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatActor {
    pub id: String,
    pub name: String,
    pub aliases: Vec<String>,
    pub sophistication_level: String,
    pub motivation: Vec<String>,
    pub preferred_malware: Vec<String>,
    pub targeted_sectors: Vec<String>,
    pub geographic_focus: Vec<String>,
}

pub struct MalwareCore {
    signatures: HashMap<String, MalwareSignature>,
    threat_intel: ThreatIntelligence,
    detection_rules: Vec<DetectionRule>,
}

#[derive(Debug, Clone)]
pub struct DetectionRule {
    pub id: String,
    pub name: String,
    pub rule_type: String,
    pub conditions: Vec<String>,
    pub weight: f64,
}

impl MalwareCore {
    pub fn new() -> Result<Self, String> {
        let mut signatures = HashMap::new();
        let mut family_info = HashMap::new();
        let campaign_data = HashMap::new();
        let mut actor_profiles = HashMap::new();

        // Initialize with sample signatures
        signatures.insert(
            "mal_001".to_string(),
            MalwareSignature {
                id: "mal_001".to_string(),
                name: "WannaCry Ransomware".to_string(),
                signature_type: SignatureType::Hash,
                pattern: "ed01ebfbc9eb5bbea545af4d01bf5f1071661840480439c6e5babe8e080e41aa".to_string(),
                family: "WannaCry".to_string(),
                severity: MalwareSeverity::Critical,
                detection_confidence: 0.95,
                created_date: Utc::now(),
                last_updated: Utc::now(),
                author: "Security Research Team".to_string(),
                tags: vec!["ransomware".to_string(), "cryptor".to_string()],
            },
        );

        // Initialize threat intelligence
        family_info.insert(
            "WannaCry".to_string(),
            MalwareFamily {
                name: "WannaCry".to_string(),
                aliases: vec!["WannaCrypt".to_string(), "WCry".to_string()],
                first_seen: chrono::DateTime::parse_from_rfc3339("2017-05-12T00:00:00Z").unwrap().with_timezone(&Utc),
                last_seen: Utc::now(),
                description: "Ransomware that spreads via SMB vulnerability".to_string(),
                capabilities: vec!["file_encryption".to_string(), "network_propagation".to_string()],
                associated_actors: vec!["Lazarus Group".to_string()],
                targeted_industries: vec!["healthcare".to_string(), "government".to_string()],
                propagation_methods: vec!["SMB_exploit".to_string(), "email_attachment".to_string()],
            },
        );

        actor_profiles.insert(
            "lazarus".to_string(),
            ThreatActor {
                id: "lazarus".to_string(),
                name: "Lazarus Group".to_string(),
                aliases: vec!["Hidden Cobra".to_string(), "APT38".to_string()],
                sophistication_level: "Advanced".to_string(),
                motivation: vec!["financial".to_string(), "espionage".to_string()],
                preferred_malware: vec!["WannaCry".to_string(), "Bankshot".to_string()],
                targeted_sectors: vec!["financial".to_string(), "cryptocurrency".to_string()],
                geographic_focus: vec!["global".to_string()],
            },
        );

        Ok(Self {
            signatures,
            threat_intel: ThreatIntelligence {
                family_info,
                campaign_data,
                actor_profiles,
            },
            detection_rules: vec![
                DetectionRule {
                    id: "rule_001".to_string(),
                    name: "High Entropy File".to_string(),
                    rule_type: "statistical".to_string(),
                    conditions: vec!["entropy > 7.5".to_string()],
                    weight: 0.6,
                },
                DetectionRule {
                    id: "rule_002".to_string(),
                    name: "Suspicious Network Behavior".to_string(),
                    rule_type: "behavioral".to_string(),
                    conditions: vec!["outbound_connections > 100".to_string()],
                    weight: 0.8,
                },
            ],
        })
    }

    pub fn analyze_file(&self, file_data: &[u8], file_path: &str) -> Result<MalwareAnalysisResult, String> {
        let file_hash = self.calculate_hash(file_data);
        
        let mut detected = false;
        let mut malware_family = None;
        let mut confidence_score = 0.0;
        let mut matched_signatures = Vec::new();
        let mut threat_level = MalwareSeverity::Low;

        // Hash-based detection
        for (sig_id, signature) in &self.signatures {
            if signature.signature_type == SignatureType::Hash && signature.pattern == file_hash {
                detected = true;
                malware_family = Some(signature.family.clone());
                confidence_score = signature.detection_confidence;
                matched_signatures.push(sig_id.clone());
                threat_level = signature.severity.clone();
                break;
            }
        }

        // Pattern-based detection
        if !detected {
            let file_str = String::from_utf8_lossy(file_data);
            for (sig_id, signature) in &self.signatures {
                if signature.signature_type == SignatureType::Pattern {
                    if file_str.contains(&signature.pattern) {
                        detected = true;
                        malware_family = Some(signature.family.clone());
                        confidence_score = signature.detection_confidence * 0.8; // Lower confidence for pattern match
                        matched_signatures.push(sig_id.clone());
                        threat_level = signature.severity.clone();
                        break;
                    }
                }
            }
        }

        // Behavioral analysis
        let behavioral_indicators = self.analyze_behavior(file_data, file_path)?;
        let network_indicators = self.extract_network_indicators(file_data)?;
        let file_indicators = self.extract_file_indicators(file_path)?;

        // Adjust confidence based on additional indicators
        if !behavioral_indicators.is_empty() || !network_indicators.is_empty() {
            confidence_score = (confidence_score + 0.2).min(1.0);
        }

        Ok(MalwareAnalysisResult {
            file_hash,
            detected,
            malware_family,
            confidence_score,
            threat_level,
            matched_signatures,
            behavioral_indicators,
            network_indicators,
            file_indicators,
            analysis_timestamp: Utc::now(),
            sandbox_report: None, // Would be populated by actual sandbox analysis
        })
    }

    pub fn scan_memory(&self, memory_dump: &[u8]) -> Result<Vec<MalwareAnalysisResult>, String> {
        let mut results = Vec::new();
        
        // Simulate memory scanning by looking for signature patterns
        for (sig_id, signature) in &self.signatures {
            if signature.signature_type == SignatureType::Pattern {
                let memory_str = String::from_utf8_lossy(memory_dump);
                if memory_str.contains(&signature.pattern) {
                    results.push(MalwareAnalysisResult {
                        file_hash: format!("memory_scan_{}", sig_id),
                        detected: true,
                        malware_family: Some(signature.family.clone()),
                        confidence_score: signature.detection_confidence * 0.7, // Lower confidence for memory scan
                        threat_level: signature.severity.clone(),
                        matched_signatures: vec![sig_id.clone()],
                        behavioral_indicators: vec![],
                        network_indicators: vec![],
                        file_indicators: vec![],
                        analysis_timestamp: Utc::now(),
                        sandbox_report: None,
                    });
                }
            }
        }

        Ok(results)
    }

    pub fn add_signature(&mut self, signature: MalwareSignature) -> Result<(), String> {
        self.signatures.insert(signature.id.clone(), signature);
        Ok(())
    }

    pub fn get_family_info(&self, family_name: &str) -> Result<Option<MalwareFamily>, String> {
        Ok(self.threat_intel.family_info.get(family_name).cloned())
    }

    pub fn search_signatures(&self, query: &str) -> Result<Vec<MalwareSignature>, String> {
        let results: Vec<MalwareSignature> = self
            .signatures
            .values()
            .filter(|sig| {
                sig.name.to_lowercase().contains(&query.to_lowercase()) ||
                sig.family.to_lowercase().contains(&query.to_lowercase()) ||
                sig.tags.iter().any(|tag| tag.to_lowercase().contains(&query.to_lowercase()))
            })
            .cloned()
            .collect();

        Ok(results)
    }

    pub fn get_threat_actor_profile(&self, actor_id: &str) -> Result<Option<ThreatActor>, String> {
        Ok(self.threat_intel.actor_profiles.get(actor_id).cloned())
    }

    fn calculate_hash(&self, data: &[u8]) -> String {
        let mut hasher = Sha256::new();
        hasher.update(data);
        format!("{:x}", hasher.finalize())
    }

    fn analyze_behavior(&self, _file_data: &[u8], _file_path: &str) -> Result<Vec<BehavioralIndicator>, String> {
        // Mock behavioral analysis
        Ok(vec![
            BehavioralIndicator {
                behavior_type: "file_encryption".to_string(),
                description: "Potential file encryption behavior detected".to_string(),
                severity: MalwareSeverity::High,
                confidence: 0.8,
                mitre_technique: Some("T1486".to_string()),
            }
        ])
    }

    fn extract_network_indicators(&self, _file_data: &[u8]) -> Result<Vec<NetworkIndicator>, String> {
        // Mock network indicator extraction
        Ok(vec![
            NetworkIndicator {
                indicator_type: "ip".to_string(),
                value: "192.168.1.100".to_string(),
                direction: "outbound".to_string(),
                protocol: "TCP".to_string(),
                port: Some(443),
                reputation_score: 0.3,
            }
        ])
    }

    fn extract_file_indicators(&self, file_path: &str) -> Result<Vec<FileIndicator>, String> {
        // Mock file indicator extraction
        Ok(vec![
            FileIndicator {
                file_path: file_path.to_string(),
                file_hash: "sample_hash".to_string(),
                file_size: 1024,
                file_type: "executable".to_string(),
                modification_time: Utc::now(),
                is_suspicious: true,
            }
        ])
    }
}

// N-API bindings for Node.js interop
#[napi]
pub struct MalwareCoreNapi {
    inner: MalwareCore,
}

#[napi]
impl MalwareCoreNapi {
    #[napi(constructor)]
    pub fn new() -> Result<Self> {
        let core = MalwareCore::new()
            .map_err(|e| napi::Error::from_reason(format!("Failed to create Malware Core: {}", e)))?;

        Ok(MalwareCoreNapi { inner: core })
    }

    #[napi]
    pub fn analyze_file_data(&self, file_data: Buffer, file_path: String) -> Result<String> {
        let result = self.inner.analyze_file(&file_data, &file_path)
            .map_err(|e| napi::Error::from_reason(format!("Failed to analyze file: {}", e)))?;

        serde_json::to_string(&result)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize result: {}", e)))
    }

    #[napi]
    pub fn scan_memory_dump(&self, memory_data: Buffer) -> Result<String> {
        let results = self.inner.scan_memory(&memory_data)
            .map_err(|e| napi::Error::from_reason(format!("Failed to scan memory: {}", e)))?;

        serde_json::to_string(&results)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize results: {}", e)))
    }

    #[napi]
    pub fn add_signature(&mut self, signature_json: String) -> Result<()> {
        let signature: MalwareSignature = serde_json::from_str(&signature_json)
            .map_err(|e| napi::Error::from_reason(format!("Failed to parse signature: {}", e)))?;

        self.inner.add_signature(signature)
            .map_err(|e| napi::Error::from_reason(format!("Failed to add signature: {}", e)))
    }

    #[napi]
    pub fn search_signatures(&self, query: String) -> Result<String> {
        let results = self.inner.search_signatures(&query)
            .map_err(|e| napi::Error::from_reason(format!("Failed to search signatures: {}", e)))?;

        serde_json::to_string(&results)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize search results: {}", e)))
    }

    #[napi]
    pub fn get_family_info(&self, family_name: String) -> Result<String> {
        let info = self.inner.get_family_info(&family_name)
            .map_err(|e| napi::Error::from_reason(format!("Failed to get family info: {}", e)))?;

        serde_json::to_string(&info)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize family info: {}", e)))
    }

    #[napi]
    pub fn get_threat_actor_profile(&self, actor_id: String) -> Result<String> {
        let profile = self.inner.get_threat_actor_profile(&actor_id)
            .map_err(|e| napi::Error::from_reason(format!("Failed to get actor profile: {}", e)))?;

        serde_json::to_string(&profile)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize actor profile: {}", e)))
    }

    #[napi]
    pub fn get_health_status(&self) -> Result<String> {
        let status = serde_json::json!({
            "status": "healthy",
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "version": env!("CARGO_PKG_VERSION"),
            "signatures_loaded": self.inner.signatures.len()
        });

        serde_json::to_string(&status)
            .map_err(|e| napi::Error::from_reason(format!("Failed to serialize health status: {}", e)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_malware_core_creation() {
        let core = MalwareCore::new();
        assert!(core.is_ok());
    }

    #[test]
    fn test_file_analysis() {
        let core = MalwareCore::new().unwrap();
        let test_data = b"test malware data";
        let result = core.analyze_file(test_data, "/tmp/test.exe");
        assert!(result.is_ok());
    }

    #[test]
    fn test_signature_search() {
        let core = MalwareCore::new().unwrap();
        let results = core.search_signatures("WannaCry");
        assert!(results.is_ok());
        assert!(!results.unwrap().is_empty());
    }
}