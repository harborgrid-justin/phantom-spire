use chrono::Utc;
use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, Ordering};
use crate::models::{
    BasicTimeline, ExploitStatus, ExploitTimeline, ExploitationStage, RiskTimepoint,
};
use crate::config::{ExploitPredictionConfig};

#[allow(dead_code)]
pub struct ExploitPredictor {
    pub(crate) prediction_models: HashMap<String, crate::models::PredictionModel>,
    pub(crate) config: ExploitPredictionConfig,
    rng_seed: AtomicU64,
}
impl ExploitPredictor {
    pub fn new(config: ExploitPredictionConfig) -> Self {
        let mut prediction_models = HashMap::new();
        prediction_models.insert("temporal_model".to_string(), crate::models::PredictionModel { model_type: "time_series".to_string(), accuracy: config.temporal_model_accuracy, last_trained: Utc::now(), },);
        prediction_models.insert("actor_model".to_string(), crate::models::PredictionModel {
                model_type: "behavioral".to_string(),
                accuracy: config.actor_model_accuracy,
                last_trained: Utc::now(),
            },);
        let seed = config.rng_seed;
        Self {
            prediction_models,
            config,
            rng_seed: AtomicU64::new(seed),
        }
    }
    pub fn assess_exploit_status(&self, cve: &crate::models::CVE) -> Result<ExploitStatus, String> {
        let age_days = if let Some(published) = cve.published_date() {
            (Utc::now() - published).num_days()
        } else {
            0 // Default to 0 days if no published date
        };
        // Probability increases with time and severity
        let base_probability = self.base_probability_for(cve);
        // Time-based probability increase
        let time_factor = (age_days as f64 / 365.0).min(1.0);
        let exploit_probability = base_probability * (self.config.base_time_factor + self.config.max_time_factor * time_factor);

        let exploit_available = self.chance(exploit_probability);
        let mut public_exploits = false;
        let mut in_the_wild = false;

        if exploit_available {
            public_exploits = self.chance(self.config.prob_public_exploits_given_available);
            if public_exploits {
                in_the_wild = self.chance(self.config.prob_in_the_wild_given_public);
            }
        }
        Ok(ExploitStatus { exploit_available, public_exploits, in_the_wild })
    }
    pub fn generate_timeline(&self, cve_id: &str) -> Result<ExploitTimeline, String> {
        let disclosure_date = Utc::now() - chrono::Duration::days(self.random_u32_range(self.config.disclosure_lookback_days_max) as i64);
        let mut stages = Vec::new();
        let mut risk_points = Vec::new();
        // Generate exploitation stages
        stages.push(ExploitationStage {
            stage: "Disclosure".to_string(),
            date: disclosure_date,
            description: "Vulnerability publicly disclosed".to_string(),
            threat_actors: vec![],
            tools_used: vec![],
        });
        if self.chance(self.config.prob_poc) {
            let poc_date = disclosure_date + chrono::Duration::days(self.random_u32_range(self.config.poc_delay_days_max) as i64);
            stages.push(ExploitationStage {
                stage: "Proof of Concept".to_string(),
                date: poc_date,
                description: "Proof of concept exploit released".to_string(),
                threat_actors: vec!["Security Researchers".to_string()],
                tools_used: vec!["Custom PoC".to_string()],
            });
        }
        if self.chance(self.config.prob_weaponization) {
            let weapon_date = disclosure_date
                + chrono::Duration::days(self.config.weaponization_min_days + self.random_u32_range(self.config.weaponization_extra_days_max) as i64);
            stages.push(ExploitationStage {
                stage: "Weaponization".to_string(),
                date: weapon_date,
                description: "Exploit weaponized for operational use".to_string(),
                threat_actors: vec!["APT Groups".to_string(), "Cyber Criminals".to_string()],
                tools_used: vec!["Metasploit".to_string(), "Custom Frameworks".to_string()],
            });
        }
        if self.chance(self.config.prob_mass_exploitation) {
            let mass_date = disclosure_date
                + chrono::Duration::days(self.config.mass_min_days + self.random_u32_range(self.config.mass_extra_days_max) as i64);
            stages.push(ExploitationStage {
                stage: "Mass Exploitation".to_string(),
                date: mass_date,
                description: "Large-scale exploitation campaigns observed".to_string(),
                threat_actors: vec!["Ransomware Groups".to_string(), "Botnets".to_string()],
                tools_used: vec!["Automated Scanners".to_string(), "Exploit Kits".to_string()],
            });
        }
        // Generate risk progression
        for i in 0..self.config.risk_progression_months {
            let date = disclosure_date + chrono::Duration::days(i as i64 * self.config.risk_progression_interval_days as i64);
            let risk_score = (i as f64 * self.config.risk_increment_per_month).min(1.0);
            let exploit_likelihood = if i < 3 { self.config.initial_exploit_likelihood } 
                                   else if i < 6 { self.config.mid_exploit_likelihood } 
                                   else { self.config.late_exploit_likelihood };
            let impact_magnitude = self.config.base_impact_magnitude + (i as f64 * self.config.impact_magnitude_increment);
            risk_points.push(RiskTimepoint { date, risk_score, exploitation_likelihood: exploit_likelihood, impact_magnitude });
        }
        Ok(ExploitTimeline {
            cve_id: cve_id.to_string(),
            disclosure_date,
            first_exploit_date: stages.get(1).map(|s| s.date),
            weaponization_date: stages.get(2).map(|s| s.date),
            mass_exploitation_date: stages.get(3).map(|s| s.date),
            patch_available_date: Some(disclosure_date + chrono::Duration::days(self.config.patch_after_days)),
            exploitation_stages: stages,
            risk_progression: risk_points,
        })
    }
    pub fn get_basic_timeline(&self, _cve_id: &str) -> Result<BasicTimeline, String> {
        // Simplified timeline for correlation
        Ok(BasicTimeline { has_public_exploits: self.chance(self.config.basic_timeline_public_exploits_probability) })
    }
    pub fn is_likely_zero_day(&self, _cve_id: &str) -> Result<bool, String> {
        // Mock zero-day detection
        Ok(self.chance(self.config.zero_day_probability))
    }
    /// Returns next pseudo-random u32 using an LCG; instance-scoped and thread-safe for &self via AtomicU64.
    fn next_random_u32(&self) -> u32 {
        let mut seed = self.rng_seed.load(Ordering::Relaxed);
        loop {
            let new_seed = seed.wrapping_mul(self.config.lcg_multiplier).wrapping_add(self.config.lcg_increment);
            match self.rng_seed.compare_exchange_weak(seed, new_seed, Ordering::Relaxed, Ordering::Relaxed) {
                Ok(_) => return (new_seed % u32::MAX as u64) as u32,
                Err(current) => seed = current,
            }
        }
    }
    /// Returns a random value in [0, max) uniformly.
    fn random_u32_range(&self, max: u32) -> u32 {
        if max == 0 { return 0; }
        self.next_random_u32() % max
    }
    /// Bernoulli trial with probability p in [0,1].
    fn chance(&self, p: f64) -> bool {
        let r = self.next_random_u32() as f64 / u32::MAX as f64;
        r < p
    }
    /// Derive base probability from CVSS severity, with a sensible default.
    fn base_probability_for(&self, cve: &crate::models::CVE) -> f64 {
        if let Some(cvss) = &cve.cvss_metrics() {
            match cvss.severity {
                crate::models::CVSSSeverity::Critical => self.config.severity_critical_probability,
                crate::models::CVSSSeverity::High => self.config.severity_high_probability,
                crate::models::CVSSSeverity::Medium => self.config.severity_medium_probability,
                crate::models::CVSSSeverity::Low => self.config.severity_low_probability,
                crate::models::CVSSSeverity::None => self.config.severity_none_probability,
            }
        } else {
            self.config.default_probability
        }
    }
}
