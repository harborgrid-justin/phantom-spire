// CVE service layer with caching and performance optimization

import { CVE, CVEAnalysisResult, AffectedProduct, CVEReference } from '../models/cve';
import { CVECore } from 'phantom-cve-core';
import { Op, fn } from 'sequelize';
import type { 
  CVE as CVEType, 
  CVEAnalysisResult as CVEAnalysisResultType,
  CVSSAttackComplexity,
  CVSSPrivilegesRequired,
  CVSSUserInteraction,
  CVSSScope,
  CVSSConfidentiality,
  CVSSIntegrity,
  CVSSAvailability
} from 'phantom-cve-core';

interface CVEFilters {
  cve_id?: string;
  severity?: string;
  min_score?: number;
  max_score?: number;
  vendor?: string;
  product?: string;
  exploit_available?: boolean;
  status?: string;
  published_after?: Date;
  published_before?: Date;
  tags?: string[];
}

interface CVESearchOptions {
  page?: number;
  limit?: number;
  sort?: string;
  order?: 'ASC' | 'DESC';
}

class CVEService {
  private cveCore: CVECore | null = null;
  private cache: Map<string, { data: any; expiry: number }> = new Map();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes

  async initialize() {
    try {
      this.cveCore = await CVECore.new();
      console.log('CVE Core initialized successfully');
    } catch (error) {
      console.error('Failed to initialize CVE Core:', error);
      throw error;
    }
  }

  private getCacheKey(operation: string, params: any): string {
    return `${operation}:${JSON.stringify(params)}`;
  }

  private setCache(key: string, data: any): void {
    this.cache.set(key, {
      data,
      expiry: Date.now() + this.CACHE_TTL
    });
  }

  private getCache(key: string): any | null {
    const cached = this.cache.get(key);
    if (cached && cached.expiry > Date.now()) {
      return cached.data;
    }
    if (cached) {
      this.cache.delete(key);
    }
    return null;
  }

  async getCVEs(filters: CVEFilters = {}, options: CVESearchOptions = {}): Promise<{
    cves: any[];
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  }> {
    const cacheKey = this.getCacheKey('getCVEs', { filters, options });
    const cached = this.getCache(cacheKey);
    if (cached) {
      return cached;
    }

    const page = options.page || 1;
    const limit = options.limit || 20;
    const offset = (page - 1) * limit;

    const whereClause: any = {};
    
    if (filters.cve_id) {
      whereClause.cve_id = { [Op.iLike]: `%${filters.cve_id}%` };
    }
    if (filters.severity) {
      whereClause.cvss_severity = filters.severity;
    }
    if (filters.min_score !== undefined) {
      whereClause.cvss_base_score = { [Op.gte]: filters.min_score };
    }
    if (filters.max_score !== undefined) {
      if (whereClause.cvss_base_score) {
        whereClause.cvss_base_score[Op.lte] = filters.max_score;
      } else {
        whereClause.cvss_base_score = { [Op.lte]: filters.max_score };
      }
    }
    if (filters.status) {
      whereClause.status = filters.status;
    }
    if (filters.published_after) {
      whereClause.published_date = { [Op.gte]: filters.published_after };
    }
    if (filters.published_before) {
      if (whereClause.published_date) {
        whereClause.published_date[Op.lte] = filters.published_before;
      } else {
        whereClause.published_date = { [Op.lte]: filters.published_before };
      }
    }
    if (filters.tags && filters.tags.length > 0) {
      whereClause.tags = { [Op.overlap]: filters.tags };
    }

    const { count, rows } = await CVE.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: CVEAnalysisResult,
          as: 'analysis',
          required: false
        },
        {
          model: AffectedProduct,
          as: 'affected_products',
          required: false
        },
        {
          model: CVEReference,
          as: 'references',
          required: false
        }
      ],
      limit,
      offset,
      order: [[options.sort || 'published_date', options.order || 'DESC']]
    });

    const result = {
      cves: rows,
      total: count,
      page,
      limit,
      totalPages: Math.ceil(count / limit)
    };

    this.setCache(cacheKey, result);
    return result;
  }

  async getCVEById(id: string): Promise<any | null> {
    const cacheKey = this.getCacheKey('getCVEById', { id });
    const cached = this.getCache(cacheKey);
    if (cached) {
      return cached;
    }

    const cve = await CVE.findByPk(id, {
      include: [
        {
          model: CVEAnalysisResult,
          as: 'analysis',
          required: false
        },
        {
          model: AffectedProduct,
          as: 'affected_products',
          required: false
        },
        {
          model: CVEReference,
          as: 'references',
          required: false
        }
      ]
    });

    if (cve) {
      this.setCache(cacheKey, cve);
    }

    return cve;
  }

  async createCVE(cveData: any): Promise<any> {
    // Create the CVE record
    const cve = await CVE.create({
      cve_id: cveData.cve_id,
      description: cveData.description,
      published_date: cveData.published_date,
      last_modified_date: cveData.last_modified_date,
      cvss_version: cveData.cvss_metrics?.version,
      cvss_base_score: cveData.cvss_metrics?.base_score,
      cvss_severity: cveData.cvss_metrics?.severity,
      cvss_attack_vector: cveData.cvss_metrics?.attack_vector,
      cvss_attack_complexity: cveData.cvss_metrics?.attack_complexity,
      cvss_privileges_required: cveData.cvss_metrics?.privileges_required,
      cvss_user_interaction: cveData.cvss_metrics?.user_interaction,
      cvss_scope: cveData.cvss_metrics?.scope,
      cvss_confidentiality_impact: cveData.cvss_metrics?.confidentiality_impact,
      cvss_integrity_impact: cveData.cvss_metrics?.integrity_impact,
      cvss_availability_impact: cveData.cvss_metrics?.availability_impact,
      cwe_id: cveData.cwe?.id,
      cwe_name: cveData.cwe?.name,
      cwe_description: cveData.cwe?.description,
      status: cveData.status,
      assigner: cveData.assigner,
      tags: cveData.tags || []
    });

    // Create affected products
    if (cveData.affected_products && cveData.affected_products.length > 0) {
      const affectedProductsData = cveData.affected_products.map((product: any) => ({
        cve_id: cve.id,
        vendor: product.vendor,
        product: product.product,
        version: product.version,
        version_start_including: product.version_start_including,
        version_end_including: product.version_end_including,
        version_start_excluding: product.version_start_excluding,
        version_end_excluding: product.version_end_excluding
      }));
      await AffectedProduct.bulkCreate(affectedProductsData);
    }

    // Create references
    if (cveData.references && cveData.references.length > 0) {
      const referencesData = cveData.references.map((ref: any) => ({
        cve_id: cve.id,
        url: ref.url,
        source: ref.source,
        tags: ref.tags || []
      }));
      await CVEReference.bulkCreate(referencesData);
    }

    // Process with CVE Core if available
    if (this.cveCore) {
      try {
        const cveForProcessing: CVEType = {
          id: cve.cve_id,
          description: cve.description,
          published_date: cve.published_date,
          last_modified_date: cve.last_modified_date,
          status: cve.status as 'reserved' | 'published' | 'rejected',
          assigner: cve.assigner,
          tags: cve.tags,
          affected_products: cveData.affected_products || [],
          references: cveData.references || []
        };

        if (cve.cvss_base_score) {
          cveForProcessing.cvss_metrics = {
            version: cve.cvss_version as any,
            base_score: cve.cvss_base_score,
            severity: cve.cvss_severity as any,
            attack_vector: cve.cvss_attack_vector as any,
            attack_complexity: (cve.cvss_attack_complexity || 'low') as any,
            privileges_required: (cve.cvss_privileges_required || 'none') as any,
            user_interaction: (cve.cvss_user_interaction || 'none') as any,
            scope: (cve.cvss_scope || 'unchanged') as any,
            confidentiality_impact: (cve.cvss_confidentiality_impact || 'none') as any,
            integrity_impact: (cve.cvss_integrity_impact || 'none') as any,
            availability_impact: (cve.cvss_availability_impact || 'none') as any
          };
        }

        const analysis = await this.cveCore.process_cve(cveForProcessing);
        await this.createAnalysisResult(cve.id, analysis);
      } catch (error) {
        console.error('Failed to process CVE with CVE Core:', error);
      }
    }

    // Clear cache
    this.clearCache();

    return this.getCVEById(cve.id);
  }

  async createAnalysisResult(cveId: string, analysis: CVEAnalysisResultType): Promise<CVEAnalysisResult> {
    return await CVEAnalysisResult.create({
      cve_id: cveId,
      exploitability: analysis.assessment.exploitability,
      impact_score: analysis.assessment.impact_score,
      risk_level: analysis.assessment.risk_level,
      affected_systems: analysis.assessment.affected_systems,
      remediation_priority: analysis.assessment.remediation_priority,
      exploit_available: analysis.assessment.exploit_available,
      public_exploits: analysis.assessment.public_exploits,
      in_the_wild: analysis.assessment.in_the_wild,
      recommendations: analysis.assessment.recommendations,
      mitigation_steps: analysis.assessment.mitigation_steps,
      related_cves: analysis.related_cves,
      threat_actors: analysis.threat_actors,
      campaigns: analysis.campaigns,
      processing_timestamp: analysis.processing_timestamp
    });
  }

  async bulkCreateCVEs(cvesData: any[]): Promise<any[]> {
    const results = [];
    
    // Process in parallel batches of 5 to avoid overwhelming the system
    for (let i = 0; i < cvesData.length; i += 5) {
      const batch = cvesData.slice(i, i + 5);
      const batchPromises = batch.map(cveData => 
        this.createCVE(cveData).catch(error => {
          console.error(`Failed to create CVE ${cveData.cve_id}:`, error);
          return null;
        })
      );
      
      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults.filter(result => result !== null));
    }

    return results;
  }

  async deleteCVE(id: string): Promise<boolean> {
    const cve = await CVE.findByPk(id);
    if (!cve) {
      return false;
    }

    // Delete related records
    await CVEAnalysisResult.destroy({ where: { cve_id: id } });
    await AffectedProduct.destroy({ where: { cve_id: id } });
    await CVEReference.destroy({ where: { cve_id: id } });
    
    // Delete the CVE
    await cve.destroy();

    // Clear cache
    this.clearCache();

    return true;
  }

  async getCVEStatistics(): Promise<any> {
    const cacheKey = this.getCacheKey('getCVEStatistics', {});
    const cached = this.getCache(cacheKey);
    if (cached) {
      return cached;
    }

    const [totalCount, severityStats, statusStats, exploitStats] = await Promise.all([
      CVE.count(),
      CVE.findAll({
        attributes: [
          'cvss_severity',
          [fn('COUNT', '*'), 'count']
        ],
        group: ['cvss_severity'],
        raw: true
      }),
      CVE.findAll({
        attributes: [
          'status',
          [fn('COUNT', '*'), 'count']
        ],
        group: ['status'],
        raw: true
      }),
      CVEAnalysisResult.findAll({
        attributes: [
          'exploit_available',
          [fn('COUNT', '*'), 'count']
        ],
        group: ['exploit_available'],
        raw: true
      })
    ]);

    const bySeverity: { [key: string]: number } = {};
    severityStats.forEach((stat: any) => {
      bySeverity[stat.cvss_severity || 'unknown'] = parseInt(stat.count);
    });

    const byStatus: { [key: string]: number } = {};
    statusStats.forEach((stat: any) => {
      byStatus[stat.status] = parseInt(stat.count);
    });

    const byExploit: { [key: string]: number } = {};
    exploitStats.forEach((stat: any) => {
      byExploit[stat.exploit_available ? 'exploit_available' : 'no_exploit'] = parseInt(stat.count);
    });

    const statistics = {
      total: totalCount,
      by_severity: bySeverity,
      by_status: byStatus,
      by_exploit: byExploit
    };

    this.setCache(cacheKey, statistics);
    return statistics;
  }

  private clearCache(): void {
    this.cache.clear();
  }

  async getHealthStatus(): Promise<any> {
    if (!this.cveCore) {
      return {
        status: 'unhealthy',
        message: 'CVE Core not initialized',
        timestamp: new Date()
      };
    }

    try {
      const coreHealth = await this.cveCore.get_health_status();
      return {
        status: 'healthy',
        cve_core: coreHealth,
        cache_size: this.cache.size,
        timestamp: new Date()
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        message: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date()
      };
    }
  }
}

export const cveService = new CVEService();
